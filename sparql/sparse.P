:- import append/3 from basics.
:- import scan_file/2 from scanner.
:- export query_unit/1, parse_file/2, test/1, test2/1, test3/1, test4/1.
:- auto_table.

parse_file(ProgramFile,AST) :-
    scan_file(ProgramFile,_Length),
    test(AST, 0, _Length).

test(Vars) --> query_unit(Vars).

% [1]  	QueryUnit	  ::=  	Query
query_unit(U) --> query(U), !.

% [1]  	Query	  ::=  	Prologue ( SelectQuery | ConstructQuery | DescribeQuery | AskQuery )
% [2]  	Query	  ::=  	Prologue ( SelectQuery | ConstructQuery | DescribeQuery | AskQuery ) ValuesClause
query(query(P,Q,CL)) --> 
	scan_white_space, prologue(P), scan_white_space, 
	( 
		select_query(Q) ; 
		construct_query(Q) ; 
		describe_query(Q) ; 
		ask_query(Q) 
	), scan_white_space, values_clause(CL).

% [3]  	UpdateUnit	  ::=  	Update
update_unit(U) --> update(U).

% [2]  	Prologue	  ::=  	BaseDecl? PrefixDecl*
% [4]  	Prologue	  ::=  	( BaseDecl | PrefixDecl )*
prologue(P) --> scan_base_decl_or_prefix_decl(P).

scan_base_decl_or_prefix_decl([B|L]) --> 
	base_decl(B),
	scan_base_decl_or_prefix_decl(L).
scan_base_decl_or_prefix_decl([B|L]) --> 
	prefix_decl(B),
	scan_base_decl_or_prefix_decl(L).
scan_base_decl_or_prefix_decl([]) --> {true}.

% [3]  	BaseDecl	  ::=  	'BASE' IRI_REF
% [5]  	BaseDecl	  ::=  	'BASE' IRIREF
base_decl(base(Base)) --> "B", "A", "S", "E", scan_white_space, iri_ref_terminal(Base).

% [4]  	PrefixDecl	  ::=  	'PREFIX' PNAME_NS IRI_REF
% [6]  	PrefixDecl	  ::=  	'PREFIX' PNAME_NS IRIREF
prefix_decl(prefix(NS, IRI)) --> "P", "R", "E", "F", "I", "X", scan_white_space, pname_ns(NS), scan_white_space, iri_ref_terminal(IRI).

% [5]  		SelectQuery	  ::=  	'SELECT' ( 'DISTINCT' | 'REDUCED' )? ( Var+ | '*' ) DatasetClause* WhereClause SolutionModifier
% [7]  		SelectQuery	  ::=  	SelectClause DatasetClause* WhereClause SolutionModifier
select_query(select(C,Clauses,W,M)) --> select_clause(C), scan_dataset_clauses(Clauses), where_clause(W), solution_modifier(M).

% [8]  	SubSelect	  ::=  	SelectClause WhereClause SolutionModifier ValuesClause
sub_select(subselect(S,W,SM,VC)) --> select_clause(S), where_clause(W), solution_modifier(SM), values_clause(VC).

% [9]  	SelectClause	  ::=  	'SELECT' ( 'DISTINCT' | 'REDUCED' )? ( ( Var | ( '(' Expression 'AS' Var ')' ) )+ | '*' )
select_clause(select_clause(D, V)) --> 
	scan_white_space, 
	"S", "E", "L", "E", "C", "T", 
	scan_white_space, 
	distinct_or_reduced_or_not(D), 
	( 
		(
			( 
				var(V1) ; 
				(
					open_paren, expression(V1a), scan_white_space, "A", "S", scan_white_space, var(V1b), close_paren,
					{ V1 = as(V1a,V1b) }
				)
			),
			scan_var_or_expression(V2),
			{ V = [V1|V2] }
		)
		; scan_white_space, "*", scan_white_space, {V = all} 
	).

scan_var_or_expression([V|L]) --> scan_white_space, var(V), scan_var_or_expression(L).
scan_var_or_expression([V|L]) --> open_paren, expression(V1a), scan_white_space, "A", "S", scan_white_space, var(V1b), close_paren, { V = as(V1a,V1b) }, scan_var_or_expression(L).
scan_var_or_expression([]) --> {true}.

distinct_or_reduced_or_not(distinct) --> "D", "I", "S", "T", "I", "N", "C", "T", scan_white_space.
distinct_or_reduced_or_not(reduced) --> "R", "E", "D", "U", "C", "E", "D", scan_white_space.
distinct_or_reduced_or_not(normal) --> {true}.

% [6]  		ConstructQuery	  ::=  	'CONSTRUCT' ConstructTemplate DatasetClause* WhereClause SolutionModifier
% [10]  	ConstructQuery	  ::=  	'CONSTRUCT' ( ConstructTemplate DatasetClause* WhereClause SolutionModifier | DatasetClause* 'WHERE' '{' TriplesTemplate? '}' SolutionModifier )
construct_query(construct(T, Clauses, Where, SolutionModifier)) --> 
	scan_white_space,
	"C", "O", "N", "S", "T", "R", "U", "C", "T", 
	scan_white_space,
	construct_template(T), scan_white_space,
	scan_dataset_clauses(Clauses), scan_white_space,
	where_clause(Where), scan_white_space,
	solution_modifier(SolutionModifier).

construct_query(construct([], Clauses, Where, SolutionModifier)) --> 
	scan_white_space,
	"C", "O", "N", "S", "T", "R", "U", "C", "T", 
	scan_white_space,
	scan_dataset_clauses(Clauses), scan_white_space,
	"W", "H", "E", "R", "E", scan_white_space,
	open_curly, ( triples_template(T1) ; { T1 = [] } ), close_curly,
	{ Where = triples(T1) },
	solution_modifier(SolutionModifier).

% [7]  		DescribeQuery	  ::=  	'DESCRIBE' ( VarOrIRIref+ | '*' ) DatasetClause* WhereClause? SolutionModifier
% [11]  	DescribeQuery	  ::=  	'DESCRIBE' ( VarOrIri+ | '*' )    DatasetClause* WhereClause? SolutionModifier
describe_query(describe(Vars, DatasetClauses, WhereClause, SolutionModifier)) --> 
	"D", "E", "S", "C", "R", "I", "B", "E", 
	scan_white_space, 
	( scan_var_or_iri(Vars), { Vars \== [] } ; ("*", {Vars = "*"}) ), scan_white_space,
	scan_dataset_clauses(DatasetClauses), scan_white_space,
	( where_clause(WhereClause) ; {WhereClause = []} ), scan_white_space,
	solution_modifier(SolutionModifier), scan_white_space.

scan_var_or_iri([]) --> {true}.
scan_var_or_iri([C|L]) --> var_or_iri(C), scan_white_space, scan_var_or_iri(L).

% [8]  		AskQuery	  ::=  	'ASK' DatasetClause* WhereClause
% [12]  	AskQuery	  ::=  	'ASK' DatasetClause* WhereClause SolutionModifier
ask_query(ask(C,W,M)) --> "A", "S", "k", scan_white_space, scan_dataset_clauses(C), scan_white_space, where_clause(W), solution_modifier(M).

scan_dataset_clauses([]) --> {true}.
scan_dataset_clauses([C|L]) --> dataset_clause(C), scan_white_space, scan_dataset_clauses(L).

% [9]  		DatasetClause	  ::=  	'FROM' ( DefaultGraphClause | NamedGraphClause )
dataset_clause(C) --> "F", "R", "O", "M", scan_white_space, default_graph_clause(C).
dataset_clause(C) --> "F", "R", "O", "M", scan_white_space, named_graph_clause(C).

% [10]  	DefaultGraphClause	  ::=  	SourceSelector
default_graph_clause(S) --> source_selector(S).

% [11]  	NamedGraphClause	  ::=  	'NAMED' SourceSelector
named_graph_clause(C) --> "N", "A", "M", "E", "D", scan_white_space, source_selector(C).

% [12]  	SourceSelector	  ::=  	IRIref
% [16]  	SourceSelector	  ::=  	iri
source_selector(S) --> iri(S).

% [13]  	WhereClause	  ::=  	'WHERE'? GroupGraphPattern
where_clause(C) --> scan_white_space, "W", "H", "E", "R", "E", scan_white_space, group_graph_pattern(C), scan_white_space.
where_clause(C) --> scan_white_space, group_graph_pattern(C), scan_white_space.

% [14]  	SolutionModifier	  ::=  	OrderClause? LimitOffsetClauses?
% [18]  	SolutionModifier	  ::=  	GroupClause? HavingClause? OrderClause? LimitOffsetClauses?
solution_modifier(modifier(G, H, O, L)) --> 
	( group_clause(G) ; { G = [] } ),
	( having_clause(H) ; { H = [] }),
	( order_clause(O) ; { O = [] } ),
	( limit_offset_clauses(L) ; { L = [] } ).

% [15]  	LimitOffsetClauses	  ::=  	( LimitClause OffsetClause? | OffsetClause LimitClause? )
limit_offset_clauses([L|O]) --> limit_clause(L), scan_white_space, ( offset_clause(O) ; {O = []}).
limit_offset_clauses([O|L]) --> offset_clause(O), scan_white_space, ( limit_clause(L) ; {L = []}).

% [16]  	OrderClause	  ::=  	'ORDER' 'BY' OrderCondition+
order_clause([C | L]) --> "O", "R", "D", "E", "R", scan_white_space, "B", "Y", scan_white_space, order_condition(C), scan_order_conditions(L).

scan_order_conditions([]) --> {true}.
scan_order_conditions([C|L]) --> scan_white_space, order_condition(C), scan_order_conditions(L).

% [17]  	OrderCondition	  ::=  	 ( ( 'ASC' | 'DESC' ) BrackettedExpression )
% 					| ( Constraint | Var )
order_condition(order(asc, E)) --> "A", "S", "C", scan_white_space, bracketted_expression(E).
order_condition(order(desc, E)) --> "D", "E", "S", "C", scan_white_space, bracketted_expression(E).
order_condition(order(C)) --> constraint(C).
order_condition(order(C)) --> var(C).

% [18]  	LimitClause	  ::=  	'LIMIT' INTEGER
limit_clause(limit(L)) --> "L", "I", "M", "I", "T", scan_white_space, integer(L).

% [19]  	OffsetClause	  ::=  	'OFFSET' INTEGER
offset_clause(offset(C)) --> "O", "F", "F", "S", "E", "T", scan_white_space, integer(C).

% [19]  	GroupClause	  ::=  	'GROUP' 'BY' GroupCondition+
group_clause([G|L]) --> scan_white_space, "G", "R", "O", "U", "P", scan_white_space, "B", "Y", scan_white_space, group_condition(G), scan_group_condition(L).

scan_group_condition([G|L]) --> group_condition(G), scan_group_condition(L).
scan_group_condition([]) --> {true}.

% [20]  	GroupCondition	  ::=  	BuiltInCall | FunctionCall | '(' Expression ( 'AS' Var )? ')' | Var
group_condition(C) --> built_in_call(C).
group_condition(C) --> function_call(C).
group_condition(E) --> open_paren, expression(E), close_paren.
group_condition(as(A,V)) --> open_paren, expression(A), scan_white_space, "A", "S", scan_white_space, var(V), close_paren.
group_condition(V) --> scan_white_space, var(V).

% [21]  	HavingClause	  ::=  	'HAVING' HavingCondition+
having_clause([H|L]) --> scan_white_space, "H", "A", "V", "I", "N", "G", scan_white_space, having_condition(H), scan_having_condidion(L).

scan_having_condidion([H|L]) --> having_condition(H), scan_having_condidion(L).
scan_having_condidion([]) --> {true}.

% [22]  	HavingCondition	  ::=  	Constraint
having_condition(C) --> constraint(C).

% [28]  	ValuesClause	  ::=  	( 'VALUES' DataBlock )?
values_clause(DB) --> scan_white_space, "V", "A", "L", "U", "E", "S", scan_white_space, data_block(DB).
values_clause([]) --> {true}.

% 29]  	Update	  ::=  	Prologue ( Update1 ( ';' Update )? )?
update(P,U) --> prologue(P), scan_white_space, update1(U1), semicolon, update(U2), { U = (U1,U2) }.
update(P,U) --> prologue(P), scan_white_space, update1(U).
update(P,[]) --> prologue(P).

% [30]  	Update1	  ::=  	Load | Clear | Drop | Add | Move | Copy | Create | InsertData | DeleteData | DeleteWhere | Modify
update1(Op) --> load(Op) ; clear(Op) ; drop(Op) ; add(Op) ; move(Op) ; copy(Op) ; 
				insert_data(Op) ; 
				delete_data(Op) ; delete_where(Op) ; 
				modify(Op).

% [31]  	Load	  ::=  	'LOAD' 'SILENT'? iri ( 'INTO' GraphRef )?
load(load(silent, I, Into)) --> 
	scan_white_space, "LOAD", 
	scan_white_space, "S" ,"I" ,"L" ,"E" ,"N" ,"T",
	iri(I),
	(
		( scan_white_space, "I", "N", "T", "O",
			graph_ref(Into)
		) ; ( { Into = [] } )
	).

load(load(normal, I, Into)) --> 
	scan_white_space, "LOAD", 
	iri(I),
	(
		( scan_white_space, "I", "N", "T", "O",
			graph_ref(Into)
		) ; ( { Into = [] } )
	).

% [32]  	Clear	  ::=  	'CLEAR' 'SILENT'? GraphRefAll
clear(clear(silent, G)) --> 
	scan_white_space, "C", "L", "E", "A", "R",
	scan_white_space, "S" ,"I" ,"L" ,"E" ,"N" ,"T", 
	graph_ref_all(G).

clear(clear(normal, G)) --> 
	scan_white_space, "C", "L", "E", "A", "R",
	graph_ref_all(G).

% [33]  	Drop	  ::=  	'DROP' 'SILENT'? GraphRefAll
drop(drop(silent, G)) --> 
	scan_white_space, "D", "R", "O", "P",
	scan_white_space, "S" ,"I" ,"L" ,"E" ,"N" ,"T", 
	graph_ref_all(G).

drop(drop(normal, G)) --> 
	scan_white_space, "D", "R", "O", "P",
	graph_ref_all(G).

% [34]  	Create	  ::=  	'CREATE' 'SILENT'? GraphRef
create(create(silent, G)) --> 
	scan_white_space, "C" ,"R" ,"E" ,"A" ,"T" ,"E", 
	scan_white_space, "S" ,"I" ,"L" ,"E" ,"N" ,"T", 
	graph_ref(G).

create(create(normal, G)) --> 
	scan_white_space, "C" ,"R" ,"E" ,"A" ,"T" ,"E", 
	graph_ref(G).

% [35]  	Add	  ::=  	'ADD' 'SILENT'? GraphOrDefault 'TO' GraphOrDefault
add(add(silent, From, To)) --> 
	scan_white_space, "A", "D", "D", 
	scan_white_space, "S" , "I" , "L" , "E" , "N" , "T", 
	graph_or_default(From), 
	scan_white_space, "T" , "O", 
	graph_or_default(To).

add(add(normal, From, To)) --> 
	scan_white_space, "A", "D", "D", 
	graph_or_default(From), 
	scan_white_space, "T" , "O", 
	graph_or_default(To).

% [36]  	Move	  ::=  	'MOVE' 'SILENT'? GraphOrDefault 'TO' GraphOrDefault
move(move(silent, From, To)) --> 
	scan_white_space, "M", "O", "V", "E", 
	scan_white_space, "S" , "I" , "L" , "E" , "N" , "T", 
	graph_or_default(From), 
	scan_white_space, "T" , "O", 
	graph_or_default(To).

move(move(normal, From, To)) --> 
	scan_white_space, "M", "O", "V", "E", 
	graph_or_default(From), 
	scan_white_space, "T" , "O", 
	graph_or_default(To).

% [37]  	Copy	  ::=  	'COPY' 'SILENT'? GraphOrDefault 'TO' GraphOrDefault
copy(copy(silent, From, To)) --> 
	scan_white_space, "C" , "O" , "P" , "Y", 
	scan_white_space, "S" , "I" , "L" , "E" , "N" , "T", 
	graph_or_default(From), 
	scan_white_space, "T" , "O", 
	graph_or_default(To).

copy(copy(normal, From, To)) --> 
	scan_white_space, "C" , "O" , "P" , "Y", 
	graph_or_default(From), 
	scan_white_space, "T" , "O", 
	graph_or_default(To).

% [38]  	InsertData	  ::=  	'INSERT DATA' QuadData
insert_data(D) --> 
	scan_white_space, "I" , "N" , "S" , "E" , "R" , "T", 
	scan_white_space, "D" , "A" , "T" , "A", 
	quad_data(D).

% [39]  	DeleteData	  ::=  	'DELETE DATA' QuadData
delete_data(P) --> 
	scan_white_space, "D" , "E" , "L" , "E" , "T" , "E", 
	scan_white_space, "D" , "A" , "T" , "A", 
	quad_data(P).

% [40]  	DeleteWhere	  ::=  	'DELETE WHERE' QuadPattern
delete_where(P) --> 
	scan_white_space, "D" , "E" , "L" , "E" , "T" , "E", 
	scan_white_space, "W" , "H" , "E" , "R" , "E", 
	quad_pattern(P).

% [41]  	Modify	  ::=  	( 'WITH' iri )? ( DeleteClause InsertClause? | InsertClause ) UsingClause* 'WHERE' GroupGraphPattern
modify(modify(With, C, Using, Where)) --> 
	scan_white_space, ( ( "W", "I", "T", "H", scan_white_space, iri(With) ) ; With = []),
	( 
		( 
			delete_clause(D),  insert_clause(DI), { C = delete(D,DI) }
			; insert_clause(C)
		) 
	),
	using_clause(Using),
	scan_white_space, "W", "H", "E", "R", "E", group_graph_pattern(Where).


% [42]  	DeleteClause	  ::=  	'DELETE' QuadPattern
delete_clause(P) --> scan_white_space, "D", "E", "L", "E", "T", "E", quad_pattern(P).

% [43]  	InsertClause	  ::=  	'INSERT' QuadPattern
insert_clause(P) --> scan_white_space, "I", "N", "S", "E", "R", "T", quad_pattern(P).

% [44]  	UsingClause	  ::=  	'USING' ( iri | 'NAMED' iri )
using_clause(I) --> scan_white_space, "U", "S", "I", "N", "G", iri(I).
using_clause(named(I)) --> scan_white_space, "N", "A", "M", "E", "D", iri(I).

% [45]  	GraphOrDefault	  ::=  	'DEFAULT' | 'GRAPH'? iri
graph_or_default(graph(I)) --> scan_white_space, "G", "R", "A", "P", "H", scan_white_space, iri(I).
graph_or_default(default(I)) --> scan_white_space, "D", "E", "F", "A", "U", "L", "T", scan_white_space, iri(I).

% [46]  	GraphRef	  ::=  	'GRAPH' iri
graph_ref(I) --> scan_white_space, "G", "R", "A", "P", "H", scan_white_space, iri(I).

% [47]  	GraphRefAll	  ::=  	GraphRef | 'DEFAULT' | 'NAMED' | 'ALL'
graph_ref_all(graph(R)) --> scan_white_space, graph_ref(R).
graph_ref_all(default) --> scan_white_space, "D", "E", "F", "A", "U", "L", "T".
graph_ref_all(named) --> scan_white_space, "N", "A", "M", "E", "D".
graph_ref_all(all) --> scan_white_space, "A", "L", "L".

% [48]  	QuadPattern	  ::=  	'{' Quads '}'
quad_pattern(Q) --> scan_white_space, open_curly, quads(Q), close_curly.

% [49]  	QuadData	  ::=  	'{' Quads '}'
quad_data(Q) --> scan_white_space, open_curly, quads(Q), close_curly.

% [50]  	Quads	  ::=  	TriplesTemplate? ( QuadsNotTriples '.'? TriplesTemplate? )*
quads([L|V]) --> scan_white_space, triples_template(L), scan_quads(V).
quads(V) --> scan_quads(V).

scan_quads([A|L]) --> quads_not_triples(A), ( dot ; {true} ), scan_quads(L).
scan_quads([dot(A,D)|L]) --> quads_not_triples(A), ( dot ; {true} ), triples_template(D), scan_quads(L).
scan_quads([]) --> {true}.

% [51]  	QuadsNotTriples	  ::=  	'GRAPH' VarOrIri '{' TriplesTemplate? '}'
quads_not_triples(Var, Template) --> 
	scan_white_space, "G", "R", "A", "P", "H", 
	scan_white_space, var_or_iri(Var), 
	scan_white_space, open_curly, ( triples_template(Template) ; {Template = []} ), close_curly.

% [52]  	TriplesTemplate	  ::=  	TriplesSameSubject ( '.' TriplesTemplate? )?
triples_template(T) --> scan_white_space, triples_same_subject(T).
triples_template(T) --> scan_white_space, triples_same_subject(T), dot.
triples_template(dot(T,T2)) --> scan_white_space, triples_same_subject(T), dot, triples_template(T2).

% [54]  	GroupGraphPatternSub	  ::=  	TriplesBlock? ( GraphPatternNotTriples '.'? TriplesBlock? )*
group_graph_pattern_sub([TB|L]) --> triples_block(TB), scan_ggps(L).
group_graph_pattern_sub(L) --> scan_ggps(L).

scan_ggps([(A1,A2)|L]) --> scan_white_space, graph_pattern_not_triples(A1), ( dot ; {true} ), triples_block(A2), scan_ggps(L).
scan_ggps([A|L]) --> scan_white_space, graph_pattern_not_triples(A), ( dot ; {true} ), scan_ggps(L).
scan_ggps([]) --> {true}.

% [59]  	ServiceGraphPattern	  ::=  	'SERVICE' 'SILENT'? VarOrIri GroupGraphPattern
service_graph_pattern(service(silent, V, G)) --> 
	scan_white_space, "S", "E", "R", "V", "I", "C", "E", 
	scan_white_space, "S", "I", "L", "E", "N", "T", 
	scan_white_space, var_or_iri(V), 
	scan_white_space, group_graph_pattern(G).

service_graph_pattern(service(normal, V, G)) --> 
	scan_white_space, "S", "E", "R", "V", "I", "C", "E", 
	scan_white_space, var_or_iri(V), 
	scan_white_space, group_graph_pattern(G).

% [60]  	Bind	  ::=  	'BIND' '(' Expression 'AS' Var ')'
bind(bind(Expression, Var)) --> 
		scan_white_space, "B", "I", "N", "D", scan_white_space, 
		open_paren, 
			expression(Expression), 
			scan_white_space, "A", "S", scan_white_space, 
			var(Var), 
		close_paren.

% [61]  	InlineData	  ::=  	'VALUES' DataBlock
inline_data(D) --> scan_white_space, "V", "A", "L", "U", "E", "S", data_block(D).

% [62]  	DataBlock	  ::=  	InlineDataOneVar | InlineDataFull
data_block(B) --> inline_data_one_var(B).
data_block(B) --> inline_data_full(B).

% [63]  	InlineDataOneVar	  ::=  	Var '{' DataBlockValue* '}'
inline_data_one_var(inline([V], D)) --> scan_white_space, var(V), scan_white_space, open_curly, scan_data_block_values(D), close_curly.

% [64]  	InlineDataFull	  ::=  	( NIL | '(' Var* ')' ) '{' ( '(' DataBlockValue* ')' | NIL )* '}'
inline_data_full(inline([], Vals)) --> scan_white_space, nil, scan_white_space, open_curly, scan_dbv(Vals), close_curly.
inline_data_full(inline(Vars, Vals)) --> scan_white_space, open_paren, scan_dvars(Vars), close_paren, scan_white_space, open_curly, scan_dbv(Vals), close_curly.

scan_dvars([A|L]) --> scan_white_space, var(A), scan_dvars(L).
scan_dvars([]) --> {true}.

scan_dbv([A|L]) --> scan_white_space, open_paren, scan_data_block_values(A), close_paren, scan_white_space, scan_dbv(L).
scan_dbv([]) --> {true}.
scan_dbv([]) --> nil.

scan_data_block_values([V|L]) --> scan_white_space, data_block_value(V), scan_data_block_values(L).
scan_data_block_values([]) --> {true}.

% [65]  	DataBlockValue	  ::=  	iri |	RDFLiteral |	NumericLiteral |	BooleanLiteral |	'UNDEF'
data_block_value(iri(I)) --> iri(I).
data_block_value(rdf_literal(I)) --> rdf_literal(I).
data_block_value(numeric_literal(I)) --> numeric_literal(I).
data_block_value(boolean_literal(I)) --> boolean_literal(I).
data_block_value(undef) --> "U", "N", "D", "E", "F".

% [66]  	MinusGraphPattern	  ::=  	'MINUS' GroupGraphPattern
minus_graph_pattern(P) --> scan_white_space, "M", "I", "N", "U", "S", scan_white_space, group_graph_pattern(P).

% [53]  	GroupGraphPattern	  ::=  	'{' ( SubSelect | GroupGraphPatternSub ) '}'
group_graph_pattern(P) --> scan_white_space, open_curly, sub_select(P), close_curly.
group_graph_pattern(P) --> scan_white_space, open_curly, group_graph_pattern_sub(P), close_curly.

% [21]  	TriplesBlock	  ::=  	TriplesSameSubject ( '.' TriplesBlock? )?
% [55]  	TriplesBlock	  ::=  	TriplesSameSubjectPath ( '.' TriplesBlock? )?
triples_block(block([B])) --> scan_white_space, triples_same_subject_path(B), scan_white_space.
triples_block(block([B1|B2])) --> scan_white_space, triples_same_subject_path(B1), dot, ( ( triples_block(B2a), { B2 = [B2a] } ) ; {B2 = []} ), scan_white_space.

% [22]  	GraphPatternNotTriples	  ::=  	OptionalGraphPattern | GroupOrUnionGraphPattern | GraphGraphPattern
% [56]  	GraphPatternNotTriples	  ::=  	GroupOrUnionGraphPattern | OptionalGraphPattern | MinusGraphPattern | GraphGraphPattern | ServiceGraphPattern | Filter | Bind | InlineData
graph_pattern_not_triples(P) --> group_or_union_graph_pattern(P).
graph_pattern_not_triples(P) --> optional_graph_pattern(P).
graph_pattern_not_triples(P) --> minus_graph_pattern(P).
graph_pattern_not_triples(P) --> graph_graph_pattern(P).
graph_pattern_not_triples(P) --> service_graph_pattern(P).
graph_pattern_not_triples(P) --> filter(P).
graph_pattern_not_triples(P) --> bind(P).
graph_pattern_not_triples(P) --> inline_data(P).

% [23]  	OptionalGraphPattern	  ::=  	'OPTIONAL' GroupGraphPattern
optional_graph_pattern(P) --> scan_white_space, "O", "P", "T", "I", "O", "N", "A", "L", scan_white_space, group_graph_pattern(P), scan_white_space.

% [24]  	GraphGraphPattern	  ::=  	'GRAPH' VarOrIRIref GroupGraphPattern
% [58]  	GraphGraphPattern	  ::=  	'GRAPH' VarOrIri GroupGraphPattern
graph_graph_pattern(graph(P,C)) --> scan_white_space, "G", "R", "A", "P", "H", scan_white_space, var_or_iri(P), scan_white_space, group_graph_pattern(C).

% [25]  	GroupOrUnionGraphPattern	  ::=  	GroupGraphPattern ( 'UNION' GroupGraphPattern )*
group_or_union_graph_pattern(union([P|L])) --> group_graph_pattern(P), scan_white_space, scan_unions(L).

scan_unions([]) --> {true}.
scan_unions([P|L]) --> scan_white_space, "U", "N", "I", "O", "N", scan_white_space, group_graph_pattern(P), scan_unions(L).

% [26]  	Filter	  ::=  	'FILTER' Constraint
filter(C) --> "F", "I", "L", "T", "E", "R", scan_white_space, constraint(C).

% [27]  	Constraint	  ::=  	BrackettedExpression | BuiltInCall | FunctionCall
constraint(C) --> bracketted_expression(C).
constraint(C) --> built_in_call(C).
constraint(C) --> function_call(C).

% [28]  	FunctionCall	  ::=  	IRIref ArgList
% [70]  	FunctionCall	  ::=  	iri ArgList
function_call(call([F|L])) --> iri(F), arg_list(L).

% [29]  	ArgList	  ::=  	( NIL | '(' Expression ( ',' Expression )* ')' )
% [71]  	ArgList	  ::=  	NIL | '(' 'DISTINCT'? Expression ( ',' Expression )* ')'
arg_list([]) --> nil.
arg_list([X|Args]) --> open_paren, expression(X), scan_expression_list(Args), close_paren.
arg_list(distinct([X|Args])) --> open_paren, "D", "I", "S", "T", "I", "N", "C", "T", scan_white_space, expression(X), scan_expression_list(Args), close_paren.

% [30]  	ConstructTemplate	  ::=  	'{' ConstructTriples? '}'
construct_template([]) --> open_curly, close_curly.
construct_template(L) --> open_curly, construct_triples(L), close_curly.

% [31]  	ConstructTriples	  ::=  	TriplesSameSubject ( '.' ConstructTriples? )?
construct_triples([T|L]) --> triples_same_subject(T), ".", construct_triples(L).
construct_triples([T]) --> triples_same_subject(T), ".".
construct_triples([T]) --> triples_same_subject(T).

% [32]  	TriplesSameSubject	  ::=  	VarOrTerm PropertyListNotEmpty |	TriplesNode PropertyList
triples_same_subject(tss(V,P)) --> var_or_term(V), scan_white_space, property_list_not_empty(P).
triples_same_subject(tss(V,P)) --> triples_node(V), scan_white_space, property_list(P).

% [33]  	PropertyListNotEmpty	  ::=  	Verb ObjectList ( ';' ( Verb ObjectList )? )*
property_list_not_empty([prop(V, L)|List]) --> verb(V), scan_white_space, object_list(L), scan_property_list(List).
property_list_not_empty([prop(V, L)]) --> verb(V), scan_white_space, object_list(L).

scan_property_list([prop(V,O)|L]) --> semicolon, verb(V), scan_white_space, object_list(O), scan_white_space, scan_property_list(L).
scan_property_list([]) --> {true}.

% [34]  	PropertyList	  ::=  	PropertyListNotEmpty?
property_list([]) --> {true}.
property_list(L) --> property_list_not_empty(L).

% [35]  	ObjectList	  ::=  	Object ( ',' Object )*
object_list([O|L]) --> object(O), comma, object_list(L).
object_list([O]) --> object(O).

% [36]  	Object	  ::=  	GraphNode
object(X) --> graph_node(X).

% [37]  	Verb	  ::=  	VarOrIRIref | 'a'
% [78]  	Verb	  ::=  	VarOrIri | 'a'
verb(a) --> "a".
verb(X) --> var_or_iri(X).

% [38]  	TriplesNode	  ::=  	Collection |	BlankNodePropertyList
triples_node(X) --> collection(X).
triples_node(X) --> blank_node_property_list(X).

% [39]  	BlankNodePropertyList	  ::=  	'[' PropertyListNotEmpty ']'
blank_node_property_list(X) --> open_square_bracket, property_list_not_empty(X), close_square_bracket.

% [40]  	Collection	  ::=  	'(' GraphNode+ ')'
collection(C) --> open_paren, scan_graph_nodes(C), {C \== []}, close_paren.

scan_graph_nodes([T|L]) --> graph_node(T), scan_white_space(), scan_graph_nodes(L).
scan_graph_nodes([]) --> {true}.

% [41]  	GraphNode	  ::=  	VarOrTerm |	TriplesNode
graph_node(X) --> var_or_term(X).
graph_node(X) --> triples_node(X).

% [42]  	VarOrTerm	  ::=  	Var | GraphTerm
var_or_term(var(X)) --> var(X).
var_or_term(X) --> graph_term(X).

% [107]  	VarOrIri	  ::=  	Var | iri
var_or_iri(var(X)) --> var(X).
var_or_iri(iri(X)) --> iri(X).

% [44]  	Var	  ::=  	VAR1 | VAR2
var(V) --> var1(V).
var(V) --> var2(V).

% [109]  	GraphTerm	  ::=  	iri |		RDFLiteral |	NumericLiteral |	BooleanLiteral |	BlankNode |	NIL
graph_term(T) --> iri(T).
graph_term(T) --> rdf_literal(T).
graph_term(T) --> numeric_literal(T).
graph_term(T) --> boolean_literal(T).
graph_term(T) --> blank_node(T).
graph_term(nil) --> nil().

% [72]  	ExpressionList	  ::=  	NIL | '(' Expression ( ',' Expression )* ')'
expression_list([]) --> nil.
expression_list([L|L2]) --> scan_white_space, open_paren, expression(L), scan_expression_list(L2), close_paren.

scan_expression_list([E|L]) --> comma, expression(E), scan_expression_list(L).
scan_expression_list([]) --> {true}.

% [46]  	Expression	  ::=  	ConditionalOrExpression
expression(E) --> conditional_or_expression(E).

% [47]  	ConditionalOrExpression	  ::=  	ConditionalAndExpression ( '||' ConditionalAndExpression )*
conditional_or_expression(E) --> conditional_and_expression(E).
conditional_or_expression(E) --> 
	conditional_and_expression(E1), 
	scan_or_expressions(E2), 
	{ 
		E2 = [] -> E = E1 ; E = expression_or(E1, E2) 
	}.

scan_or_expressions(E) --> 
	scan_white_space, "|", "|", scan_white_space,
	conditional_and_expression(E1), 
	scan_or_expressions(E2), 
	{ 
		E2 = [] -> E = E1 ; E = expression_or(E1, E2) 
	}.
scan_or_expressions(E) --> "|", "|", conditional_and_expression(E).
scan_or_expressions([]) --> {true}.

% [48]  	ConditionalAndExpression	  ::=  	ValueLogical ( '&&' ValueLogical )*
conditional_and_expression(E) --> 
	value_logical(E1), 
	scan_value_logical(L), 
	{
		L = [] -> E = E1 ; E = expression_and(E1, L)
	}.
conditional_and_expression(E) --> value_logical(E1), {E = E1}.

scan_value_logical(L) --> 
	"&", "&", 
	value_logical(L1), 
	scan_value_logical(L2), 
	{
		L2 = [] -> L = L1 ; L = expression_and(L1, L2)
	}.
scan_value_logical(L) --> "&", "&", value_logical(L).
scan_value_logical([]) --> {true}.

% [49]  	ValueLogical	  ::=  	RelationalExpression
value_logical(L) --> scan_white_space, relational_expression(L).

% [81]  	TriplesSameSubjectPath	  ::=  	VarOrTerm PropertyListPathNotEmpty |	TriplesNodePath PropertyListPath
triples_same_subject_path((T,L)) --> scan_white_space, var_or_term(T), scan_white_space, property_list_not_empty(L).
triples_same_subject_path((T,L)) --> scan_white_space, triples_node_path(T), scan_white_space, property_list_path(L).
	
% [82]  	PropertyListPath	  ::=  	PropertyListPathNotEmpty?
property_list_path(P) --> property_list_path_not_empty(P) ; {P = []}.

% [83]  	PropertyListPathNotEmpty	  ::=  	( VerbPath | VerbSimple ) ObjectListPath ( ';' ( ( VerbPath | VerbSimple ) ObjectList )? )*
property_list_path_not_empty([property(VP,LP) | L]) --> ( verb_path(VP) ; verb_simple(VP) ), scan_white_space, object_list_path(LP), scan_property_list_path_not_empty(L).

scan_property_list_path_not_empty([property(VP,LP)|L]) --> 
	scan_white_space, ";", scan_white_space, 
	( verb_path(VP) ; verb_simple(VP) ), scan_white_space, 
	object_list(LP), scan_property_list_path_not_empty(L).
scan_property_list_path_not_empty([]) --> {true}.

% [84]  	VerbPath	  ::=  	Path
verb_path(P) --> path(P).

% [85]  	VerbSimple	  ::=  	Var
verb_simple(V) --> scan_white_space, var(V).

% [86]  	ObjectListPath	  ::=  	ObjectPath ( ',' ObjectPath )*
object_list_path([P1|P]) --> object_path(P1), scan_object_path(P).

scan_object_path([P1|P]) --> comma, object_path(P1), scan_object_path(P).
scan_object_path([]) --> {true}.

% [87]  	ObjectPath	  ::=  	GraphNodePath
object_path(P) --> graph_node_path(P).

% [88]  	Path	  ::=  	PathAlternative
path(P) --> path_alternative(P).

% [89]  	PathAlternative	  ::=  	PathSequence ( '|' PathSequence )*
path_alternative([S1|S]) --> path_sequence(S1), scan_path_alternative(S).

scan_path_alternative([S1|S]) --> scan_white_space, "|", scan_white_space, path_sequence(S1), scan_path_sequence(S).
scan_path_alternative([]) --> {true}.

% [90]  	PathSequence	  ::=  	PathEltOrInverse ( '/' PathEltOrInverse )*
path_sequence([S1|S]) --> path_elt_or_inverse(S1), scan_path_sequence(S).

scan_path_sequence([S1|S]) --> scan_white_space, "/", scan_white_space, path_elt_or_inverse(S1), scan_path_sequence(S).
scan_path_sequence([]) --> {true}.

% [91]  	PathElt	  ::=  	PathPrimary PathMod?
path_elt(elt(Path,Mod)) --> path_primary(Path), path_mod(Mod).
path_elt(elt(Path,[])) --> path_primary(Path).

% [92]  	PathEltOrInverse	  ::=  	PathElt | '^' PathElt
path_elt_or_inverse(P) --> scan_white_space, path_elt(P).
path_elt_or_inverse(inv(P)) --> scan_white_space, "^", path_elt(P).

% [93]  	PathMod	  ::=  	'?' | '*' | '+'
path_mod("?") --> scan_white_space, "?".
path_mod("*") --> scan_white_space, "*".
path_mod("+") --> scan_white_space, "+".

% [94]  	PathPrimary	  ::=  	iri | 'a' | '!' PathNegatedPropertySet | '(' Path ')'
path_primary(P) --> scan_white_space, iri(P).
path_primary(a) --> scan_white_space, "a".
path_primary(not(P)) --> scan_white_space, "!", path_negated_property_set(P).
path_primary(P) --> open_paren, path(P), close_paren.

% [95]  	PathNegatedPropertySet	  ::=  	PathOneInPropertySet | '(' ( PathOneInPropertySet ( '|' PathOneInPropertySet )* )? ')'
path_negated_property_set(S) --> scan_white_space, path_one_in_property_set(S).
path_negated_property_set([]) --> open_paren, close_paren.
path_negated_property_set([S1|S]) --> open_paren, path_one_in_property_set(S1), scan_white_space, scan_path_one_in(S), close_paren.

scan_path_one_in([]) --> {true}.
scan_path_one_in([S|S2]) --> scan_white_space, "|", scan_white_space, path_one_in_property_set(S), scan_white_space, scan_path_one_in(S2).

% [96]  	PathOneInPropertySet	  ::=  	iri | 'a' | '^' ( iri | 'a' )
path_one_in_property_set(iri(R)) --> scan_white_space, iri(R).
path_one_in_property_set(a) --> scan_white_space, "a".
path_one_in_property_set(caret_iri(R)) --> scan_white_space, "^", iri(R).
path_one_in_property_set(caret_a) --> scan_white_space, "^", "a".

% [100]  	TriplesNodePath	  ::=  	CollectionPath |	BlankNodePropertyListPath
triples_node_path(P) --> scan_white_space, collection_path(P).
triples_node_path(P) --> scan_white_space, blank_node_property_list_path(P).

% [101]  	BlankNodePropertyListPath	  ::=  	'[' PropertyListPathNotEmpty ']'
blank_node_property_list_path(P) --> open_square_bracket, property_list_path_not_empty(P), close_square_bracket.

% [103]  	CollectionPath	  ::=  	'(' GraphNodePath+ ')'
collection_path([P1|P]) --> open_paren, graph_node_path(P1), scan_graph_node_path(P), close_paren.

scan_graph_node_path([]) --> {true}.
scan_graph_node_path([P|Pl]) --> scan_white_space, graph_node_path(P), scan_graph_node_path(Pl).

% [105]  	GraphNodePath	  ::=  	VarOrTerm |	TriplesNodePath
graph_node_path(V) --> scan_white_space, var_or_term(V).
graph_node_path(V) --> scan_white_space, triples_node_path(V).

% [114]  	RelationalExpression	  ::=  	NumericExpression ( '=' NumericExpression | '!=' NumericExpression | '<' NumericExpression | '>' NumericExpression | '<=' NumericExpression | '>=' NumericExpression | 'IN' ExpressionList | 'NOT' 'IN' ExpressionList )?
relational_expression(L) --> scan_white_space, numeric_expression(L).
relational_expression(L) --> scan_white_space, numeric_expression(L1), scan_white_space, "=", 		scan_white_space, numeric_expression(L2), { L = eq(L1, L2) 		}.
relational_expression(L) --> scan_white_space, numeric_expression(L1), scan_white_space, "!", "=", 	scan_white_space, numeric_expression(L2), { L = neq(L1, L2) 	}.
relational_expression(L) --> scan_white_space, numeric_expression(L1), scan_white_space, "<", 		scan_white_space, numeric_expression(L2), { L = lt(L1, L2) 		}.
relational_expression(L) --> scan_white_space, numeric_expression(L1), scan_white_space, ">", 		scan_white_space, numeric_expression(L2), { L = gt(L1, L2) 		}.
relational_expression(L) --> scan_white_space, numeric_expression(L1), scan_white_space, "<", "=", 	scan_white_space, numeric_expression(L2), { L = lte(L1, L2) 	}.
relational_expression(L) --> scan_white_space, numeric_expression(L1), scan_white_space, ">", "=", 	scan_white_space, numeric_expression(L2), { L = gte(L1, L2) 	}.
relational_expression(L) --> scan_white_space, numeric_expression(L1), scan_white_space, "I", "N",  scan_white_space, expression_list(EL), 	  { L = in(L1, EL)		}.
relational_expression(L) --> 
					scan_white_space, numeric_expression(L1), scan_white_space, 
					"N", "O", "T", scan_white_space, "I", "N",  scan_white_space, 
					expression_list(EL), { L = notin(L1, EL) }.

% [51]  	NumericExpression	  ::=  	AdditiveExpression
numeric_expression(E) --> additive_expression(E).

% [116]  	AdditiveExpression	  ::=  	MultiplicativeExpression ( '+' MultiplicativeExpression | '-' MultiplicativeExpression | ( NumericLiteralPositive | NumericLiteralNegative ) ( ( '*' UnaryExpression ) | ( '/' UnaryExpression ) )* )*
additive_expression(E) 				--> multiplicative_expression(E).
additive_expression(E) 				--> multiplicative_expression(E1), "+", scan_multiplicative_expression(E2), 	{ E = plus(E1, E2) 	}.
additive_expression(E) 				--> multiplicative_expression(E1), "-", scan_multiplicative_expression(E2), 	{ E = minus(E1, E2) }.

scan_multiplicative_expression(E) --> multiplicative_expression(E).
scan_multiplicative_expression(E) --> numeric_literal_positive(E).
scan_multiplicative_expression(E) --> numeric_literal_negative(E).
scan_multiplicative_expression(E) --> numeric_literal_positive(E1),  "*", scan_unary_expression(E2), 			{ E = times(E1, E2) 	}.
scan_multiplicative_expression(E) --> numeric_literal_negative(E1),  "*", scan_unary_expression(E2), 			{ E = times(E1, E2) 	}.
scan_multiplicative_expression(E) --> numeric_literal_positive(E1),  "/", scan_unary_expression(E2), 			{ E = divide(E1, E2) 	}.
scan_multiplicative_expression(E) --> numeric_literal_negative(E1),  "/", scan_unary_expression(E2), 			{ E = divide(E1, E2) 	}.
scan_multiplicative_expression(E) --> multiplicative_expression(E1), "+", scan_multiplicative_expression(E2), 	{ E = plus(E1, E2)	 	}.
scan_multiplicative_expression(E) --> multiplicative_expression(E1), "-", scan_multiplicative_expression(E2), 	{ E = minus(E1, E2) 	}.
scan_multiplicative_expression(E) --> numeric_literal_positive(E1), scan_multiplicative_expression(E2), 		{ E = plus(E1, E2) 		}.
scan_multiplicative_expression(E) --> numeric_literal_negative(E1), scan_multiplicative_expression(E2), 		{ E = plus(E1, E2) 		}.

% [53]  	MultiplicativeExpression	  ::=  	UnaryExpression ( '*' UnaryExpression | '/' UnaryExpression )*
multiplicative_expression(E) --> scan_unary_expression(E).

scan_unary_expression(E) --> unary_expression(E).
scan_unary_expression(E) --> unary_expression(E1), "*", scan_unary_expression(E2), { E = times(E1, E2) }.
scan_unary_expression(E) --> unary_expression(E1), "/", scan_unary_expression(E2), { E = divide(E1, E2) }.

% [54]  	UnaryExpression	  ::=  	  '!' PrimaryExpression 
% 					|	'+' PrimaryExpression 
% 					|	'-' PrimaryExpression 
% 					|	PrimaryExpression
unary_expression(bang(E))  	--> "!", primary_expression(E).
unary_expression(plus(E))  	--> "+", primary_expression(E).
unary_expression(minus(E)) 	--> "-", primary_expression(E).
unary_expression(E) 		--> 	 primary_expression(E).

% [119]  	PrimaryExpression	  ::=  	BrackettedExpression | BuiltInCall | iriOrFunction | RDFLiteral | NumericLiteral | BooleanLiteral | Var
primary_expression(X) --> bracketted_expression(X).
primary_expression(X) --> built_in_call(X).
primary_expression(X) --> iri_or_function(X).
primary_expression(X) --> rdf_literal(X).
primary_expression(X) --> numeric_literal(X).
primary_expression(X) --> boolean_literal(X).
primary_expression(X) --> var(X).

% [56]  	BrackettedExpression	  ::=  	'(' Expression ')'
bracketted_expression((X)) --> open_paren, expression(X), close_paren.

% [121]  	BuiltInCall	  ::=  	  Aggregate 
% 				|	'STR' '(' Expression ')' 
built_in_call(builtin(str, E)) --> "S", "T", "R", open_paren, expression(E), close_paren.
% 				|	'LANG' '(' Expression ')'
built_in_call(builtin(lang,E)) --> "L", "A", "N", "G", open_paren, expression(E), close_paren. 
% 				|	'LANGMATCHES' '(' Expression ',' Expression ')' 
built_in_call(builtin(langmatches,E)) --> "L", "A", "N", "G", "M", "A", "T", "C", "H", "E", "S", open_paren, expression(E), close_paren.
% 				|	'DATATYPE' '(' Expression ')' 
built_in_call(builtin(datatype,E)) --> "D", "A", "T", "A", "T", "Y", "P", "E", open_paren, expression(E), close_paren.
% 				|	'BOUND' '(' Var ')' 
built_in_call(builtin(bound,E)) --> "B", "O", "U", "N", "D", open_paren, expression(E), close_paren.
% 				|	'IRI' '(' Expression ')' 
built_in_call(builtin(iri, E)) --> "I","R","I", open_paren, expression(E), close_paren.
% 				|	'URI' '(' Expression ')' 
built_in_call(builtin(uri, E)) --> "U","R","I", open_paren, expression(E), close_paren.
% 				|	'BNODE' ( '(' Expression ')' | NIL ) 
built_in_call(builtin(bnode, '')) --> "B", "N", "O", "D", "E", nil.
built_in_call(builtin(bnode, E)) --> "B", "N", "O", "D", "E", open_paren, expression(E), close_paren.
% 				|	'RAND' NIL 
built_in_call(builtin(rand)) --> "R", "A", "N", "D", nil.
% 				|	'ABS' '(' Expression ')' 
built_in_call(builtin(abs, E)) -->  "A", "B", "S", open_paren, expression(E), close_paren.
% 				|	'CEIL' '(' Expression ')' 
built_in_call(builtin(ceil, E)) -->  "C", "E", "I", "L", open_paren, expression(E), close_paren.
% 				|	'FLOOR' '(' Expression ')' 
built_in_call(builtin(floor, E)) -->  "F", "L", "O", "O", "R", open_paren, expression(E), close_paren.
% 				|	'ROUND' '(' Expression ')' 
built_in_call(builtin(round, E)) -->  "R", "O", "U", "N", "D", open_paren, expression(E), close_paren.
% 				|	'CONCAT' ExpressionList 
built_in_call(builtin(concat,EL)) --> "C", "O", "N", "C", "A", "T", expression_list(EL).
% 				|	SubstringExpression 
built_in_call(builtin(substring, [E1, E2, E3])) -->  substring_expression(E1, E2, E3).
% 				|	'STRLEN' '(' Expression ')' 
built_in_call(builtin(strlen, E)) -->  "S", "T", "R", "L", "E", "N", open_paren, expression(E), close_paren.
% 				|	StrReplaceExpression 
built_in_call(builtin(strreplace, [E1, E2, E3, E4])) -->  str_replace_expression(E1, E2, E3, E4).
% 				|	'UCASE' '(' Expression ')' 
built_in_call(builtin(ucase, E)) -->  "U", "C", "A", "S", "E", open_paren, expression(E), close_paren.
% 				|	'LCASE' '(' Expression ')' 
built_in_call(builtin(lcase, E)) -->  "L", "C", "A", "S", "E", open_paren, expression(E), close_paren.
% 				|	'ENCODE_FOR_URI' '(' Expression ')' 
built_in_call(builtin(encode_for_uri, E)) -->  "E", "N", "C", "O", "D", "E", "_", "F", "O", "R", "_", "U", "R", "I", open_paren, expression(E), close_paren.
% 				|	'CONTAINS' '(' Expression ',' Expression ')' 
built_in_call(builtin(contains, [E1,E2])) --> "C", "O", "N", "T", "A", "I", "N", "S", open_paren, expression(E1), comma, expression(E2), close_paren.
% 				|	'STRSTARTS' '(' Expression ',' Expression ')' 
built_in_call(builtin(strstarts, [E1,E2])) --> "S", "T", "R", "S", "T", "A", "R", "T", "S", open_paren, expression(E1), comma, expression(E2), close_paren.
% 				|	'STRENDS' '(' Expression ',' Expression ')' 
built_in_call(builtin(strends, [E1,E2])) --> "S", "T", "R", "E", "N", "D", "S", open_paren, expression(E1), comma, expression(E2), close_paren.
% 				|	'STRBEFORE' '(' Expression ',' Expression ')' 
built_in_call(builtin(strbefore, [E1,E2])) --> "S", "T", "R", "B", "E", "F", "O", "R", "E", open_paren, expression(E1), comma, expression(E2), close_paren.
% 				|	'STRAFTER' '(' Expression ',' Expression ')' 
built_in_call(builtin(strafter, [E1,E2])) --> "S", "T", "R", "A", "F", "T", "E", "R", open_paren, expression(E1), comma, expression(E2), close_paren.
% 				|	'YEAR' '(' Expression ')' 
built_in_call(builtin(yea, E)) --> "Y", "E", "A", "R", open_paren, expression(E), close_paren.
% 				|	'MONTH' '(' Expression ')' 
built_in_call(builtin(month, E)) --> "M", "O", "N", "T", "H", open_paren, expression(E), close_paren.
% 				|	'DAY' '(' Expression ')' 
built_in_call(builtin(day, E)) --> "D", "A", "Y", open_paren, expression(E), close_paren.
% 				|	'HOURS' '(' Expression ')' 
built_in_call(builtin(hours, E)) --> "H", "O", "U", "R", "S", open_paren, expression(E), close_paren.
% 				|	'MINUTES' '(' Expression ')' 
built_in_call(builtin(minutes, E)) --> "M" ,"I" ,"N" ,"U" ,"T" ,"E" ,"S", open_paren, expression(E), close_paren.
% 				|	'SECONDS' '(' Expression ')' 
built_in_call(builtin(seconds, E)) --> "S", "E", "C", "O", "N", "D", "S", open_paren, expression(E), close_paren.
% 				|	'TIMEZONE' '(' Expression ')' 
built_in_call(builtin(timezone, E)) --> "T", "I", "M", "E", "Z", "O", "N", "E", open_paren, expression(E), close_paren.
% 				|	'TZ' '(' Expression ')' 
built_in_call(builtin(tz, E)) --> "T", "Z", open_paren, expression(E), close_paren.
% 				|	'NOW' NIL 
built_in_call(builtin(now)) --> "N", "O", "W", nil.
% 				|	'UUID' NIL 
built_in_call(builtin(uuid)) --> "U", "U", "I", "D", nil.
% 				|	'STRUUID' NIL 
built_in_call(builtin(struuid)) --> "S", "T", "R", "U", "U", "I", "D", nil.
% 				|	'MD5' '(' Expression ')' 
built_in_call(builtin(md5,E)) --> "M", "D", "5", open_paren, expression(E), close_paren.
% 				|	'SHA1' '(' Expression ')' 
built_in_call(builtin(sha1,E)) --> "S", "H", "A", "1", open_paren, expression(E), close_paren.
% 				|	'SHA256' '(' Expression ')' 
built_in_call(builtin(sha256,E)) --> "S", "H", "A", "2", "5", "6", open_paren, expression(E), close_paren.
% 				|	'SHA384' '(' Expression ')' 
built_in_call(builtin(sha384,E)) --> "S", "H", "A", "3", "8", "4", open_paren, expression(E), close_paren.
% 				|	'SHA512' '(' Expression ')' 
built_in_call(builtin(sha512,E)) --> "S", "H", "A", "5", "1", "2", open_paren, expression(E), close_paren.
% 				|	'COALESCE' ExpressionList 
built_in_call(builtin(coalesce,EL)) --> "C", "O", "A", "L", "E", "S", "C", "E", expression_list(EL).
% 				|	'IF' '(' Expression ',' Expression ',' Expression ')' 
built_in_call(builtin(if,[Condition,Expression,Else])) --> 
	"I", "F", open_paren, 
		expression(Condition), comma, 
		expression(Expression), comma, 
		expression(Else), 
	close_paren.
% 				|	'STRLANG' '(' Expression ',' Expression ')' 
built_in_call(builtin(strlang,[E1,E2])) --> "S", "T", "R", "L", "A", "N", "G", open_paren, expression(E1), comma, expression(E2), close_paren.
% 				|	'STRDT' '(' Expression ',' Expression ')' 
built_in_call(builtin(strdt,[E1,E2])) --> "S", "T", "R", "D", "T", open_paren, expression(E1), comma, expression(E2), close_paren.
% 				|	'sameTerm' '(' Expression ',' Expression ')' 
built_in_call(builtin(sameterm,E)) --> "s", "a", "m", "e", "T", "e", "r", "m", open_paren, expression(E), close_paren.
% 				|	'isIRI' '(' Expression ')' 
built_in_call(builtin(is_iri, E)) --> "i", "s", "I", "R", "I", open_paren, expression(E), close_paren.
% 				|	'isURI' '(' Expression ')' 
built_in_call(builtin(is_uri, E)) --> "i", "s", "U", "R", "I", open_paren, expression(E), close_paren.
% 				|	'isBLANK' '(' Expression ')' 
built_in_call(builtin(is_blank, E)) --> "i", "s", "B", "L", "A", "N", "K", open_paren, expression(E), close_paren.
% 				|	'isLITERAL' '(' Expression ')' 
built_in_call(builtin(is_literal, E)) --> "i", "s", "L", "I", "T", "E", "R", "A", "L", open_paren, expression(E), close_paren.
% 				|	'isNUMERIC' '(' Expression ')' 
built_in_call(builtin(is_numeric, E)) --> "i", "s", "N", "U", "M", "E", "R", "I", "C", open_paren, expression(E), close_paren.
% 				|	RegexExpression 
built_in_call(builtin(regex, E)) --> regex_expression(E).
% 				|	ExistsFunc 
built_in_call(builtin(exists, E)) --> exists_func(E).
% 				|	NotExistsFunc
built_in_call(builtin(not_exists, E)) --> not_exists_func(E).

% [58]  	RegexExpression	  ::=  	'REGEX' '(' Expression ',' Expression ( ',' Expression )? ')'
regex_expression(regex([X1, X2])) --> "R", "E", "G", "E", "X", open_paren, expression(X1), comma, expression(X2), close_paren.
regex_expression(regex([X1, X2, X3])) --> "R", "E", "G", "E", "X", open_paren, expression(X1), comma, expression(X2), comma, expression(X3), close_paren.

% [123]  	SubstringExpression	  ::=  	'SUBSTR' '(' Expression ',' Expression ( ',' Expression )? ')'
substring_expression(Exp1, Exp2, Exp3) --> 
	scan_white_space, "S", "U", "B", "S", "T", "R", open_paren,
	expression(Exp1), comma, expression(Exp2), comma, expression(Exp3), close_paren, {!}.

substring_expression(Exp1, Exp2, '') --> 
	scan_white_space, "S", "U", "B", "S", "T", "R", open_paren,
	expression(Exp1), comma, expression(Exp2), close_paren, {!}.

% [124]  	StrReplaceExpression	  ::=  	'REPLACE' '(' Expression ',' Expression ',' Expression ( ',' Expression )? ')'
str_replace_expression(Exp1, Exp2, Exp3, Exp4) --> 
	scan_white_space, "R", "E", "P", "L", "A", "C", "E", open_paren,
	expression(Exp1), comma, expression(Exp2), comma, expression(Exp3), comma, expression(Exp4), close_paren, {!}.

str_replace_expression(Exp1, Exp2, Exp3, '') --> 
	scan_white_space, "R", "E", "P", "L", "A", "C", "E", open_paren,
	expression(Exp1), comma, expression(Exp2), comma, expression(Exp3), close_paren.

% [125]  	ExistsFunc	  ::=  	'EXISTS' GroupGraphPattern
exists_func(GGP) --> scan_white_space, "E", "X", "I", "S", "T", "S", scan_white_space, group_graph_pattern(GGP).

% [126]  	NotExistsFunc	  ::=  	'NOT' 'EXISTS' GroupGraphPattern
not_exists_func(GGP) --> scan_white_space, "N", "O", "T", scan_white_space, "E", "X", "I", "S", "T", "S", scan_white_space, group_graph_pattern(GGP).

% [127]  	Aggregate	  ::=  	  
% 		'COUNT' '(' 'DISTINCT'? ( '*' | Expression ) ')' 
aggregate(count, D, Op) --> 
	"C","O","U","N","T", open_paren, 
	distinct_or_not(D),
	expression_or_star(Op), close_paren.
%		| 'SUM' '(' 'DISTINCT'? Expression ')' 
aggregate(sum, D, Op) --> 
	"S", "U", "M", open_paren, 
	distinct_or_not(D),
	expression(Op), close_paren.
%		| 'MIN' '(' 'DISTINCT'? Expression ')' 
aggregate(min, D, Op) --> 
	"M", "I", "N", open_paren, 
	distinct_or_not(D),
	expression(Op), close_paren.
%		| 'MAX' '(' 'DISTINCT'? Expression ')' 
aggregate(max, D, Op) --> 
	"M", "A", "X", open_paren, 
	distinct_or_not(D),
	expression(Op), close_paren.
%		| 'AVG' '(' 'DISTINCT'? Expression ')' 
aggregate(avg, D, Op) --> 
	"A","V", "G", open_paren, 
	distinct_or_not(D),
	expression(Op), close_paren.
%		| 'SAMPLE' '(' 'DISTINCT'? Expression ')' 
aggregate(sample, D, Op) --> 
	"S","A","M","P","L","E", open_paren, 
	distinct_or_not(D),
	expression(Op), close_paren.
%		| 'GROUP_CONCAT' '(' 'DISTINCT'? Expression ( ';' 'SEPARATOR' '=' String )? ')'
aggregate(group_concat(Sep), D, Op) --> 
	"S","A","M","P","L","E", open_paren, 
	distinct_or_not(D),
	expression(Op), 
	scan_white_space, ";", scan_white_space,
	"S", "E", "P", "A", "R", "A", "T", "O", "R",
	scan_white_space, "=", scan_white_space,
	string(Sep), 
	close_paren.

aggregate(group_concat(), D, Op) --> 
	"S","A","M","P","L","E", open_paren, 
	distinct_or_not(D),
	expression(Op), 
	close_paren.
 
distinct_or_not(distinct) --> "D", "I", "S", "T", "I", "N", "C", "T", scan_white_space, { ! }.
distinct_or_not(all) --> {true, !}.
expression_or_star(all) --> "*".
expression_or_star(E) --> expression(E).

% [128]  	iriOrFunction	  ::=  	iri ArgList?
iri_or_function(F) --> iri(F1), arg_list(Args), { F = function(F1, Args) }.
iri_or_function(F) --> iri(F1), { F = iri(F1) }.

% [129]  	RDFLiteral	  ::=  	String ( LANGTAG | ( '^^' iri ) )?
rdf_literal(rdf_lit(String, lang(L))) --> string(String), langtag(L).
rdf_literal(rdf_lit(String, iri(L))) --> string(String), "^", "^", iri(L).
rdf_literal(rdf_lit(String, '')) --> string(String).

% [61]  	NumericLiteral	  ::=  	NumericLiteralUnsigned | NumericLiteralPositive | NumericLiteralNegative
numeric_literal(N) --> numeric_literal_unsigned(N).
numeric_literal(N) --> numeric_literal_positive(N).
numeric_literal(N) --> numeric_literal_negative(N).

% [62]  	NumericLiteralUnsigned	  ::=  	INTEGER |	DECIMAL |	DOUBLE
numeric_literal_unsigned(N) --> integer(L), { N = int(L) }.
numeric_literal_unsigned(N) --> decimal(L), { N = dec(L) }.
numeric_literal_unsigned(N) --> double(L, E), { N = doub(L,E) }.

% [63]  	NumericLiteralPositive	  ::=  	INTEGER_POSITIVE |	DECIMAL_POSITIVE |	DOUBLE_POSITIVE
numeric_literal_positive(N) --> integer_positive(L), { N = int(L) }.
numeric_literal_positive(N) --> decimal_positive(L), { N = dec(L) }.
numeric_literal_positive(N) --> double_positive(L,E), { N = doub(L,E) }.

% [64]  	NumericLiteralNegative	  ::=  	INTEGER_NEGATIVE |	DECIMAL_NEGATIVE |	DOUBLE_NEGATIVE
numeric_literal_negative(N) --> integer_negative(L), { N = int(L) }.
numeric_literal_negative(N) --> decimal_negative(L), { N = dec(L) }.
numeric_literal_negative(N) --> double_negative(L,E), { N = doub(L,E) }.

% [65]  	BooleanLiteral	  ::=  	'true' |	'false'
boolean_literal('true') --> "T", "R", "U", "E".
boolean_literal('true') --> "t", "r", "u", "e".

boolean_literal('false') --> "F", "A", "L", "S", "E".
boolean_literal('false') --> "f", "a", "l", "s", "e".

% [66]  	String	  ::=  	STRING_LITERAL1 | STRING_LITERAL2 | STRING_LITERAL_LONG1 | STRING_LITERAL_LONG2
string(S) --> string_literal1(S).
string(S) --> string_literal2(S).
string(S) --> string_literal_long1(S).
string(S) --> string_literal_long2(S).

% [136]  	iri	  	  ::=  	IRIREF  |	PrefixedName
iri(Ref) --> iri_ref_terminal(Ref).
iri(Ref) --> prefixed_name(Ref).

% [68]  	PrefixedName	  ::=  	PNAME_LN | PNAME_NS
prefixed_name(ln(LN, S)) 	--> pname_ln(LN, S).
prefixed_name(LN) 			--> pname_ns(LN).

% [69]  	BlankNode	  ::=  	BLANK_NODE_LABEL |	ANON
blank_node(blank(B))		--> blank_node_label(B).
blank_node(blank([])) 		--> anon().

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% Terminals %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [70]  	IRI_REF	  ::=  	'<' ([^<>"{}|^`\]-[#x00-#x20])* '>'
iri_ref_terminal(URL) --> "<", iri_string(URLL), { atom_codes(URL, URLL) }, ">".

iri_string([]) --> {true}.
iri_string([X|URL]) --> 
	[X], 
	{ 
		X \== ">", 
		X \== 0'", 
		X \== "{", 
		X \== "}",
		X \== "`",
		X \== 0'\\ 
	}, 
	iri_string(URL).

% [71]  	PNAME_NS	  ::=  	PN_PREFIX? ':'
pname_ns(V) --> pn_prefix(V), ":".

% [72]  	PNAME_LN	  ::=  	PNAME_NS PN_LOCAL
pname_ln(NS,L) --> pname_ns(NS), pn_local(L). 
	
% [142]  	BLANK_NODE_LABEL	  ::=  	'_:' ( PN_CHARS_U | [0-9] ) ((PN_CHARS|'.')* PN_CHARS)?
blank_node_label(B) --> "_", ":", pn_chars_u(B).
blank_node_label(B) --> "_", ":", [B], { B @>= 0, B @=< 9 }.
blank_node_label(B) --> "_", ":", pn_chars_u(B1), scan_blank_node_label(B2), { string:concat_atom([B1,B2], B) }.
blank_node_label(B) --> "_", ":", [B1], { B1 @>= 0, B1 @=< 9 }, scan_blank_node_label(B2), { string:concat_atom([B1,B2], B) }.

scan_blank_node_label(B) --> pn_chars(B).
scan_blank_node_label(B) --> pn_chars(B1), scan_blank_node_label(B2), { string:concat_atom([B1,B2], B) }.
scan_blank_node_label(B) --> ".", scan_blank_node_label(B2), { string:concat_atom(['.',B2], B) }.

% [74]  	VAR1	  ::=  	'?' VARNAME
var1(V) --> "?", varname(V).

% [75]  	VAR2	  ::=  	'$' VARNAME
var2(V) --> "$", varname(V).

% [76]  	LANGTAG	  ::=  	'@' [a-zA-Z]+ ('-' [a-zA-Z0-9]+)*
langtag(L) --> "@", scan_letters(L1), { L1 \== [] }, scan_hyphen_seq(L2), { lists:append(L1, L2, L3), atom_codes(L, L3) }.

scan_letters([]) --> {true}.
scan_letters([X|L]) --> [X], 
	{(
		( X @>= 0'a, X @=< 0'z ) ;
		( X @>= 0'A, X @=< 0'Z )
	)}, scan_letters(L).

scan_hyphen_seq([]) --> {true}.
scan_hyphen_seq(S) --> "-", scan_alphanumeric(X1), { X1 \== [] }, scan_hyphen_seq(L), { append([0'-|X1], L, S) }.

scan_alphanumeric([]) --> {true}.
scan_alphanumeric([X|A]) --> [X], 
	{ (
		( X @>= 0'a, X @=< 0'z ) ;
		( X @>= 0'A, X @=< 0'Z ) ;
		( X @>= 0'0, X @=< 0'9 ) 
	) }, scan_alphanumeric(A).

% [77]  	INTEGER	  ::=  	[0-9]+
integer(I) --> scan_numbers(I2), { I2 \== [], number_codes(I, I2) }.

% [78]  	DECIMAL	  ::=  	[0-9]+ '.' [0-9]* | '.' [0-9]+
decimal(D) --> scan_numbers(I1), ".", scan_numbers(I2), { I2 \== [], append(I1, [0'.|I2], I3), I3 \== [], number_codes(D, I3) }.

% [79]  	DOUBLE	  ::=  	[0-9]+ '.' [0-9]* EXPONENT | '.' ([0-9])+ EXPONENT | ([0-9])+ EXPONENT
double(D,E) --> scan_numbers(I1), ".", scan_numbers(I2), exponent(E), { append(I1, [0'.|I2], I3), I3 \== [], number_codes(D, I3) }.

% [80]  	INTEGER_POSITIVE	  ::=  	'+' INTEGER
integer_positive(I) --> "+", integer(I).

% [81]  	DECIMAL_POSITIVE	  ::=  	'+' DECIMAL
decimal_positive(D) --> "+", decimal(D).

% [82]  	DOUBLE_POSITIVE	  ::=  	'+' DOUBLE
double_positive(D, E) --> "+", double(D, E).

% [83]  	INTEGER_NEGATIVE	  ::=  	'-' INTEGER
integer_negative(I) --> "-", integer(I2), { I is -1 * I2 }.

% [84]  	DECIMAL_NEGATIVE	  ::=  	'-' DECIMAL
decimal_negative(D) --> "-", decimal(D2), { D is -1 * D2 }.

% [85]  	DOUBLE_NEGATIVE	  ::=  	'-' DOUBLE
double_negative(D,E) --> "-", double(D2, E), { D is -1 * D2 }.

% [86]  	EXPONENT	  ::=  	[eE] [+-]? [0-9]+
exponent(E) --> "e", "-", scan_numbers(E2), { number_codes(E3, E2), E is -1 * E3 }.
exponent(E) --> "e", "+", scan_numbers(E2), { number_codes(E3, E2), E = E3 }.
exponent(E) --> "E", "-", scan_numbers(E2), { number_codes(E3, E2), E is -1 * E3 }.
exponent(E) --> "E", "+", scan_numbers(E2), { number_codes(E3, E2), E = E3 }.
exponent(E) --> "e", scan_numbers(E2), { number_codes(E3, E2), E = E3 }.
exponent(E) --> "E", scan_numbers(E2), { number_codes(E3, E2), E = E3 }.

scan_numbers([N|Ns]) --> [N], { check_numeric(N) }, scan_numbers(Ns), !.
scan_numbers([]) --> { true }.

check_numeric(N) :- N @>= 0'0, N @=< 0'9.

% [87]  	STRING_LITERAL1	  ::=  	"'" ( ([^#x27#x5C#xA#xD]) | ECHAR )* "'"
string_literal1(S) --> "'", 
	(
		scan_literal1(S1),
		{ string:concat_atom(S1, S) }
	), "'".

scan_literal1([]) --> {true}.
scan_literal1([C|S]) -->
	[Cs], 
	{
		Cs \== 0x27, 
		Cs \== 0x5C,			
		Cs \== 0xA,
		Cs \== 0xD,
		atom_codes(C, [Cs])
	},
	scan_literal1(S).
scan_literal1([C|S]) --> echar(C), scan_literal1(S).

% [88]  	STRING_LITERAL2	  ::=  	'"' ( ([^#x22#x5C#xA#xD]) | ECHAR )* '"'
string_literal2(S) --> "\"", 
	(
		scan_literal2(S1),
		{ string:concat_atom(S1, S) }
	), "\"".

scan_literal2([]) --> {true}.
scan_literal2([C|S]) -->
	[Cs], 
	{
		Cs \== 0x22, 
		Cs \== 0x5C,			
		Cs \== 0xA,
		Cs \== 0xD,
		atom_codes(C, [Cs])
	},
	scan_literal2(S).
scan_literal2([C|S]) --> echar(C), scan_literal2(S).

% [89]  	STRING_LITERAL_LONG1	  ::=  	"'''" ( ( "'" | "''" )? ( [^'\] | ECHAR ) )* "'''"
string_literal_long1(S) --> 
	"'", "'", "'",
	scan_literal_long1(S1),
	{ string:concat_atom(S1, S) },
	"'", "'", "'".

scan_literal_long1([]) --> {true}.
scan_literal_long1([C|S]) -->
	(
		"'", {C1 = ''''} ; 
		"''", {C1 = ''''''} ; 
		{C1 = ''}
	),
	[C3], { C3 \== 0'', C3 \== 0'\\ }, 
	{ atom_codes(C2, [C3]), string:concat_atom([C1|C2], C) },
	scan_literal_long1(S).

scan_literal_long1([C|S]) -->
	(
		"'", {C1 = ''''} ; 
		"''", {C1 = ''''''} ; 
		{C1 = ''}
	),
	echar(C2),
	{ string:concat_atom([C1|C2], C) },
	scan_literal_long1(S).


% [90]  	STRING_LITERAL_LONG2	  ::=  	'"""' ( ( '"' | '""' )? ( [^"\] | ECHAR ) )* '"""'
string_literal_long2(S) --> 
	"\"", "\"", "\"",
	scan_literal_long2(S1),
	{ string:concat_atom(S1, S) },
	"\"", "\"", "\"".

scan_literal_long2([]) --> {true}.
scan_literal_long2([C|S]) -->
	(
		"\"", {C1 = '"'} ; 
		"\"\"", {C1 = '""'} ; 
		{C1 = ''}
	),
	[C3], { C3 \== 0'", C3 \== 0'\\ }, 
	{ atom_codes(C2, [C3]), string:concat_atom([C1|C2], C) },
	scan_literal_long2(S).

scan_literal_long2([C|S]) -->
	(
		"\"", {C1 = '"'} ; 
		"\"\"", {C1 = '""'} ; 
		{C1 = ''}
	),
	echar(C2),
	{ string:concat_atom([C1|C2], C) },
	scan_literal_long2(S).

% [91]  	ECHAR	  ::=  	'\' [tbnrf\"']
echar('\t') 	-->  "\\", "t".
echar('\b')		-->  "\\", "b".
echar('\n')		-->  "\\", "n".
echar('\r')		-->  "\\", "r".
echar('\f')		-->  "\\", "f".
echar('\\') 	-->  "\\", "\\".
echar('\"') 	-->  "\\", [0'"].
echar('''') 	-->  "\\", "'".


% [92]  	NIL	  ::=  	'(' WS* ')'
nil() --> open_paren, scan_white_space(), close_paren.

% [93]  	WS	  ::=  	#x20 | #x9 | #xD | #xA
white_space(X) --> [X], { white_space(X) }.
white_space(0x20).
white_space(0x9).
white_space(0xD).
white_space(0xA).

% [94]  	ANON	  ::=  	'[' WS* ']'
anon() --> "[", scan_white_space(), "]".

scan_white_space() --> {true}.
scan_white_space() --> white_space(_), scan_white_space().

% [95]  	PN_CHARS_BASE	  ::=  	[A-Z] | [a-z] | [#x00C0-#x00D6] | [#x00D8-#x00F6] | [#x00F8-#x02FF] | 
%%			[#x0370-#x037D] | [#x037F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | 
%%			[#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
pn_chars_base(C) --> [X], { pn_chars_base_check_code(X), atom_codes(C, [X]) }.

% pn_chars_base will read in as many successive characters that fit the bill (essentially pn_chars_base*)
pn_chars_base_string(Chars) --> pn_chars_base_scan(C), { C \== [], atom_codes(Chars, C) }.
pn_chars_base_scan(Atom) --> [X], 
		{ pn_chars_base_check_code(X) }, 
		pn_chars_base_scan(Chars), 					% try to match more characters 
		{ Atom = [X|Chars] }.

pn_chars_base_scan([]) --> {true}.

pn_chars_base_check_code(C) :-	
	(
		( C @>= 0'A, C @=< 0'Z ); 				%% [A - Z]
		( C @>= 0'a, C @=< 0'z ); 				%% [a - z]
		( C @>= 0x00C0, C @=< 0x00D6 ); 		%% [#x00C0-#x00D6]
		( C @>= 0x00D8, C @=< 0x00F6 ); 		%% [#x00D8-#x00F6] 
		( C @>= 0x00F8, C @=< 0x02FF ); 		%% [#x00F8-#x02FF] 
		( C @>= 0x0370, C @=< 0x037D ); 		%% [#x0370-#x037D]
		( C @>= 0x037F, C @=< 0x1FFF ); 		%% [#x037F-#x1FFF]
		( C @>= 0x200C, C @=< 0x200D ); 		%% [#x200C-#x200D]
		( C @>= 0x2070, C @=< 0x218F ); 		%% [#x2070-#x218F]
		( C @>= 0x2C00, C @=< 0x2FEF ); 		%% [#x2C00-#x2FEF]
		( C @>= 0x3001, C @=< 0xD7FF ); 		%% [#x3001-#xD7FF]
		( C @>= 0xF900, C @=< 0xFDCF ); 		%% [#xF900-#xFDCF]
		( C @>= 0xFDF0, C @=< 0xFFFD ); 		%% [#xFDF0-#xFFFD] 
		( C @>= 0x10000, C @=< 0xEFFFF ) 		%% [#x10000-#xEFFFF]
	).


% [96]  	PN_CHARS_U	  ::=  	PN_CHARS_BASE | '_'
pn_chars_u(C) --> [X], { pn_chars_u_check_code(X), atom_codes(C, [X]) }.

% pn_chars_u_string will read in as many successive characters that fit the bill (essentially pn_chars_u*)
pn_chars_u_string(Chars) --> pn_chars_u_scan(C), { C \== [], atom_codes(Chars, C) }.

pn_chars_u_scan([]) --> {true}.
pn_chars_u_scan(Atom) --> [X], 
		{ pn_chars_u_check_code(X) }, 
		pn_chars_u_scan(Chars), 		% try to match more characters 
		{ Atom = [X|Chars] }.

%% accept all codes from pn_chars_base_check_code with the addition of the underscore
pn_chars_u_check_code(0'_).	
pn_chars_u_check_code(X) :- pn_chars_base_check_code(X).


% [97]  	VARNAME	  ::=  	( PN_CHARS_U | [0-9] ) ( PN_CHARS_U | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040] )*
varname(V) --> 
	% check the first characters
	( 										% ( PN_CHARS_U | [0-9] )
		pn_chars_u(F) ; 
		(
			[G], { G @>= 0'0, G @=< 0'9 , atom_codes(F, [G]) } 
		)
	), 			
	varname_scan(F3),{ atom_codes(F2, F3) },% ( PN_CHARS_U | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040] )*
	{ string:concat_atom([F|F2], V) }.		% combine into a string

varname_scan([]) --> {true}.
varname_scan(Atom) --> [X], 
		{ varname_check_code(X) }, 
		varname_scan(Chars), 		% try to match more characters 
		{ Atom = [X|Chars] }.

varname_check_code(X) :- 
			pn_chars_u_check_code(X) ;		% PN_CHARS_U
			( X @>= 0'0, X @=< 0'9 ) ;		% [0-9]
			X =:= 0x00B7 ;					% #x00B7
			( X @>= 0x0300, X @=< 0x036F ); % [#x0300-#x036F]
			( X @>= 0x203F, X @=< 0x2040 ). % [#x203F-#x2040]

% [98]  	PN_CHARS	  ::=  	PN_CHARS_U | '-' | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040]
pn_chars(C) --> [X], { pn_chars_check_code(X), atom_codes(C, [X]) }.

pn_chars_check_code(C) :-
	varname_check_code(C) ;	
	C =:= 0'-.

% pn_chars_string will read in as many successive characters that fit the bill (essentially pn_chars*)
pn_chars_string(Chars) --> pn_chars_scan(C), { C \== [], atom_codes(Chars, C) }.

pn_chars_scan([]) --> {true}.
pn_chars_scan(Atom) --> [X], 
		{ pn_chars_check_code(X) }, 
		pn_chars_scan(Chars), 			% try to match more characters 
		{ Atom = [X|Chars] }.

% [99]  	PN_PREFIX	  ::=  	PN_CHARS_BASE ((PN_CHARS|'.')* PN_CHARS)?
pn_prefix(Prefix) --> 
	pn_chars_base(C1),  					% PN_CHARS_BASE
	(
		(									% ((PN_CHARS|'.')* PN_CHARS)?
			pn_prefix_scan(C3),
			pn_chars(C4),
			{ lists:append(C3, [C4], C2) }
		) ; 
		{ C2 = [] }
	), { string:concat_atom([C1|C2], Prefix) }.

pn_prefix_scan([]) 		--> {true}.
pn_prefix_scan([C1|C]) 	--> pn_chars(C1), pn_prefix_scan(C). % PN_CHARS
pn_prefix_scan(['.'|C]) --> ".", pn_prefix_scan(C). 		% .

% [169]  	PN_LOCAL	  ::=  	( PN_CHARS_U | ':' | [0-9] | PLX ) ((PN_CHARS | '.' | ':' | PLX)* (PN_CHARS | ':' | PLX) )?
pn_local(V) --> 
	( 
		pn_chars_u(C1) 
		; ( [C1a],  { C1a @>=0'0, C1a @=< 0'9, atom_codes(C1, [C1a] ) }  )
		; ( ":", { C1 = ":" } )
		; plx(C1)
	),
	(
		pn_local_scan(C2)
		; { C2 = [] }
	), 
	(
		pn_chars_u(C3) 
		; ( [C3a],  { C3a @>=0'0, C3a @=< 0'9, atom_codes(C3, [C3a] ) }  )
		; ( ":", { C3 = ":" } )
		; plx(C3)
		; { C3 = [] }
	),
	{ string:concat_atom([C1|[C2|C3]], V) }.

pn_local_scan([]) --> {true}.
pn_local_scan([C|S]) --> pn_chars(C), pn_local_scan(S).
pn_local_scan(["."|S]) --> ".", pn_local_scan(S).
pn_local_scan([":"|S]) --> ":", pn_local_scan(S).
pn_local_scan([C|S]) --> plx(C), pn_local_scan(S).


% [170]  	PLX	  ::=  	PERCENT | PN_LOCAL_ESC
plx(P) --> percent(P).
plx(P) --> pn_local_esc(P).

% [171]  	PERCENT	  ::=  	'%' HEX HEX
percent(P) --> "%", hex(P1), hex(P2), { number_codes(P, [P1|[P2]]) }.

% [172]  	HEX	  ::=  	[0-9] | [A-F] | [a-f]
hex(V) --> [V], {V @>= 0'0, V @=< 0'9}.
hex(V) --> [V], {V @>= "A", V @=< "F"}.
hex(V) --> [V], {V @>= "a", V @=< "f"}.

% [173]  	PN_LOCAL_ESC	  ::=  	'\' ( '_' | '~' | '.' | '-' | '!' | '$' | '&' | "'" | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%' )
pn_local_esc("_") --> "\\", "_".
pn_local_esc("~") --> "\\", "~".
pn_local_esc(".") --> "\\", ".".
pn_local_esc("-") --> "\\", "-".
pn_local_esc("!") --> "\\", "!".
pn_local_esc("$") --> "\\", "$".
pn_local_esc("&") --> "\\", "&".
pn_local_esc("'") --> "\\", "'".
pn_local_esc("(") --> "\\", "(".
pn_local_esc(")") --> "\\", ")".
pn_local_esc("*") --> "\\", "*".
pn_local_esc("+") --> "\\", "+".
pn_local_esc(",") --> "\\", ",".
pn_local_esc(";") --> "\\", ";".
pn_local_esc("=") --> "\\", "=".
pn_local_esc("/") --> "\\", "/".
pn_local_esc("?") --> "\\", "?".
pn_local_esc("#") --> "\\", "#".
pn_local_esc("@") --> "\\", "@".
pn_local_esc("%") --> "\\", "%".

%% allow spaces inbetween parenthesis
open_paren() --> "(", scan_white_space.
close_paren() --> scan_white_space, ")".

open_square_bracket() --> "[", scan_white_space.
close_square_bracket() --> scan_white_space, "]".

open_curly() --> "{", scan_white_space.
close_curly() --> scan_white_space, "}".

dot() --> scan_white_space, ".", scan_white_space.
comma() --> scan_white_space, ",", scan_white_space.
semicolon() --> scan_white_space, ";", scan_white_space.

printc() :- 'C'(_, X, _), writeln(X), fail.

test(X)  :- parse_file(test, X).
test2(X) :- parse_file(q1, X).
test3(X) :- parse_file(q2, X).
test4(X) :- parse_file(q3, X).


