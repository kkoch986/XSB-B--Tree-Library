
%% Load the C Library
%% ?- [bt].

:- import bt_init/3 from bt.
:- import bt_close/1 from bt.
:- import bt_size/2 from bt.
:- import bt_insert/2 from bt.
:- import bt_get/3 from bt.
:- import bt_getl/2 from bt.
:- import bt_getnext/2 from bt.
:- import bt_drop/2 from bt.
:- import bt_prefix_jump/2, bt_prefix_next/2 from bt.
:- import bt_range_init/3, bt_range_next/2 from bt.
:- import bt_mcm_init/1 from bt.
:- import bt_mcm_first/1, bt_mcm_last/1 from bt.
:- import bt_mcm_next/1, bt_mcm_prev/1 from bt.
:- import bt_mcm_jump/2, bt_mcm_jump_rev/2 from bt.
:- import bt_mcm_key/2, bt_mcm_val/2 from bt.
:- import bt_mcm_next_key/2 from bt.
:- import bt_tree_name/2 from bt.
:- import bt_trans_start/1, bt_trans_commit/1, bt_trans_abort/1 from bt.

:- import numbervars/3, unnumbervars/3 from num_vars.

%% This function will initialize a btree
btinit(Pred/Arity, Argument, Handle) :- bt_init(Pred/Arity, Argument, Handle).

%% Close a B+ Tree.
btclose(Handle) :- bt_close(Handle).

%% Return the size of the B+ Tree in Handle
btsize(Handle, Size) :- bt_size(Handle, Size).

%% Drop a B+ Tree.
btdrop(Pred/Arity, Argument) :- bt_drop(Pred/Arity, Argument).

%% Insert a Term into a B+ Tree
btinsert(Handle, Term) :- 
	numbervars(Term, 0, _),
	bt_insert(Handle, Term).

%% Non-Deterministically find terms that match the key exactly.
btget(TreeHandle, Key, Value) :- 
	bt_getl(TreeHandle, Key),
	btgetnext(TreeHandle, Value0), 
	unnumbervars(Value0, 0, Value).

btgetnext(TreeHandle, Value) :- 
	bt_getnext(TreeHandle, Value0),
	(
		Value = Value0 
		; btgetnext(TreeHandle, Value)
	).

%% btprefix/3
%% Jump the tree cursor to the first element whose key has the given prefix.
%% Note this method cannot be called simulaneously on a single tree handle.
%% In order to execute 2 prefix or range queries at the same time, 2 calls 
%% to bt_init must be made (even if to the same tree).
%% Call with:
%% btprefix(+TreeHandle, +KeyPrefix, -Value).
btprefix(TreeHandle, Prefix, Value) :- 
	bt_prefix_jump(TreeHandle, Prefix),
	btprefixnext(TreeHandle, Value0),
	unnumbervars(Value0, 0, Value).

%% helper for Non-Determinism to btprefix.
btprefixnext(TreeHandle, Value) :-
	bt_prefix_next(TreeHandle, Value0),
	( 
			unnumbervars(Value0, 0, Value)
			; btprefixnext(TreeHandle, Value)
	).

%% btrange/4
%% Jump the tree cursor to the first element whose key has the given prefix,
%% and continue until the UpperBound has been reached.
%% Note this method cannot be called simulaneously on a single tree handle.
%% In order to execute 2 prefix or range queries at the same time, 2 calls 
%% to bt_init must be made (even if to the same tree).
%% Call with:
%% btrange(+TreeHandle, +LowerBound, +UpperBound, -Value).
btrange(TreeHandle, LowerBound, UpperBound, Value) :-
	bt_range_init(TreeHandle, LowerBound, UpperBound),
	btrangenext(TreeHandle, Value).

btrangenext(TreeHandle, Value) :-
	bt_range_next(TreeHandle, Value0),
	(
		unnumbervars(Value0, 0, Value) 
		; btrangenext(TreeHandle, Value)
	).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Manual Cursor Mode (mcm)
%% This allows the programmer to manually control the cursor.
%%
%% To use, first call btminit(+TreeHandle), then use the preds
%% below to traverse the cursor
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% btminit/1. Initialize MCM on a tree handle. As with prefix
%% and range queries, this ties up this tree handle so it cannot
%% be used for anything else while processing in MCM.
btminit(TreeHandle) :- bt_mcm_init(TreeHandle).

%% btmfirst/1. Move the cursor to the first record in the tree.
btmfirst(TreeHandle) :- bt_mcm_first(TreeHandle).

%% btmlast/1. Move the cursor to the first record in the tree.
btmlast(TreeHandle) :- bt_mcm_last(TreeHandle).

%% btmnext/1. Move the cursor to the next consecutive record in the tree.
btmnext(TreeHandle) :- bt_mcm_next(TreeHandle).

%% btmprev/1. Move the cursor to the previous record in the tree.
btmprev(TreeHandle) :- bt_mcm_prev(TreeHandle).

%% btmjump/2. Move the cursor to the first record matching the key
%% or the nearest match if there are no matches.
btmjump(TreeHandle, Key) :- bt_mcm_jump(TreeHandle, Key).

%% btmjump_rev/2. Move the cursor to the last record matching the key
%% or the nearest match if there are no matches.
btmjump_rev(TreeHandle, Key) :- bt_mcm_jump_rev(TreeHandle, Key).

%% btmkey/2. Returns the current Key which the cursor is pointing to.
%% Does not affect the cursor position.
btmkey(TreeHandle, Key) :- bt_mcm_key(TreeHandle, Key0), unnumbervars(Key0, 0, Key).

%% btmval/2. Returns the current Value which the cursor is pointing to.
%% Does not affect the cursor position.
%% Notice the use of Val0, from the latest version, calls to the c level
%% functions can be made only with variables when values are returned.
btmval(TreeHandle, Val) :- bt_mcm_val(TreeHandle, Val0), unnumbervars(Val0, 0, Val).


%% btgetall/2. Returns each value in the tree on at a time starting
%% from the first indexed value to the last. NOTE: Uses MCM so it will
%% tie up the tree handle for the time you are using it.
btgetall(TreeHandle, Value) :- 
	btminit(TreeHandle), 
	btmfirst(TreeHandle),
	btgetallnext(TreeHandle, Value).

btgetallnext(TreeHandle, Value) :- 
	btmval(TreeHandle, Value0),
	( 
		unnumbervars(Value0, 0, Value) ; 
			btmnext(TreeHandle),
			btgetallnext(TreeHandle, Value)
	).


%% btgetall_rev/2. Returns each value in the tree on at a time starting
%% from the last indexed value to the first. NOTE: Uses MCM so it will
%% tie up the tree handle for the time you are using it.
btgetall_rev(TreeHandle, Value) :- 
	btminit(TreeHandle), 
	btmlast(TreeHandle),
	btgetallprev(TreeHandle, Value).

btgetallprev(TreeHandle, Value) :- 
	btmval(TreeHandle, Value0),
	( 
		unnumbervars(Value0, 0, Value) ; 
		btmprev(TreeHandle),
		btgetallprev(TreeHandle, Value)
	).


%% btgetall_key/2. Returns each key in the tree on at a time starting
%% from the first indexed value to the last. NOTE: Uses MCM so it will
%% tie up the tree handle for the time you are using it.
btgetall_key(TreeHandle, Value) :- 
	btminit(TreeHandle), 
	btmfirst(TreeHandle),
	btgetallnext_key(TreeHandle, Value).

btgetallnext_key(TreeHandle, Value) :- 
	btmkey(TreeHandle, Value0),
	( 
		unnumbervars(Value0, 0, Value)  ; 
			bt_mcm_next_key(TreeHandle),
			btgetallnext_key(TreeHandle, Value)
	).

%% btgetall_rev/2. Returns each key in the tree on at a time starting
%% from the last indexed value to the first. NOTE: Uses MCM so it will
%% tie up the tree handle for the time you are using it.
btgetall_key_rev(TreeHandle, Value) :- 
	btminit(TreeHandle), 
	btmlast(TreeHandle),
	btgetallnext_key_rev(TreeHandle, Value).

btgetallnext_key_rev(TreeHandle, Value) :- 
	btmkey(TreeHandle, Value0),
	( 
		unnumbervars(Value0, 0, Value)  ; 
			btmprev(TreeHandle),
			btgetallnext_key_rev(TreeHandle, Value)
	).


%% btname/2. Returns the name of the tree identified by the handle.
%% This name also identifies the directory in which the tree files
%% are held.
btname(Handle, Name) :- bt_tree_name(Handle, Name).

%% btstrans/1. Initiates a transaction on the given database.
btstrans(Handle) :- bt_trans_start(Handle).

%% btctrans/1. Commits a transaction on the given database.
btctrans(Handle) :- bt_trans_commit(Handle).

%% btatrans/1. Aborts a transaction on the given database.
btatrans(Handle) :- bt_trans_abort(Handle).








