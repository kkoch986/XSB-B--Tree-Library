
%% Load the C Library
%% ?- [bt].

:- import bt_init/3 from bt_c.
:- import bt_close/1 from bt_c.
:- import bt_size/2 from bt_c.
:- import bt_insert/2, bt_insert_keep/2 from bt_c.
:- import bt_getl/2 from bt_c.
:- import bt_getnext/2 from bt_c.
:- import bt_drop/2 from bt_c.
:- import bt_prefix_jump/2, bt_prefix_next/2 from bt_c.
:- import bt_range_init/3, bt_range_next/2 from bt_c.
:- import bt_mcm_init/1 from bt_c.
:- import bt_mcm_first/1, bt_mcm_last/1 from bt_c.
:- import bt_mcm_next/1, bt_mcm_prev/1 from bt_c.
:- import bt_mcm_jump/2, bt_mcm_jump_rev/2 from bt_c.
:- import bt_mcm_key/2, bt_mcm_val/2 from bt_c.
:- import bt_mcm_next_key/1 from bt_c.
:- import bt_mcm_out/1 from bt_c.
:- import bt_tree_name/2 from bt_c.
:- import bt_trans_start/1, bt_trans_commit/1, bt_trans_abort/1 from bt_c.
%:- import bt_cur_enc_repair/1, bt_cur_enc_repair_fone/1 from bt_c.
:- import bt_cur_enc_repair_fone/1 from bt_c.
:- import bt_repair/2 from bt_c.
:- import bt_export/2, bt_import/2 from bt_c.

:- import numbervars/3, unnumbervars/3 from num_vars.

:- export btinit/3, btclose/1, btsize/2, btdrop/2, btname/2.
:- export btinsert/2, btinsertkeep/2.
:- export btget/3, btprefix/3, btrange/4, btgetall/2, btgetall_rev/2, 
			btgetall_key/2, btgetall_key_rev/2.
:- export btimport/2, btexport/2, btpurgecorrupt/1, btrepair/2.
:- export btminit/1, btmfirst/1, btmlast/1, btmnext/1, btmprev/1, 
			btmjump/2, btmjump_rev/2, btmkey/2, btmval/2, btmout/1.
:- export btstrans/1, btctrans/1, btatrans/1.

%% This function will initialize a btree
btinit(Pred/Arity, Argument, Handle) :- bt_init(Pred/Arity, Argument, Handle).

%% Close a B+ Tree.
btclose(Handle) :- bt_close(Handle).

%% Return the size of the B+ Tree in Handle
btsize(Handle, Size) :- bt_size(Handle, Size).

%% Drop a B+ Tree.
btdrop(Pred/Arity, Argument) :- bt_drop(Pred/Arity, Argument).

%% Insert a Term into a B+ Tree
btinsert(Handle, Term) :- 
	numbervars(Term, 0, _),
	bt_insert(Handle, Term).

%% insert a term into a B+ Tree only if it doesnt exist already
btinsertkeep(Handle, Term) :- 
	numbervars(Term, 0, _),
	bt_insert_keep(Handle, Term).

	
%% Non-Deterministically find terms that match the key exactly.
btget(TreeHandle, Key, Value) :- 
	bt_getl(TreeHandle, Key),
	btgetnext(TreeHandle, Value).

btgetnext(TreeHandle, Value) :- 
	bt_getnext(TreeHandle, Value0),
	(
		unnumbervars(Value0, 0, Value1), 
		Value = Value1
		; btgetnext(TreeHandle, Value)
	).

%% btprefix/3
%% Jump the tree cursor to the first element whose key has the given prefix.
%% Note this method cannot be called simulaneously on a single tree handle.
%% In order to execute 2 prefix or range queries at the same time, 2 calls 
%% to bt_init must be made (even if to the same tree).
%% Call with:
%% btprefix(+TreeHandle, +KeyPrefix, -Value).
btprefix(TreeHandle, Prefix, Value) :- 
	bt_prefix_jump(TreeHandle, Prefix),
	btprefixnext(TreeHandle, Value).

%% helper for Non-Determinism to btprefix.
btprefixnext(TreeHandle, Value) :-
	bt_prefix_next(TreeHandle, Value0),
	( 
			unnumbervars(Value0, 0, Value1),
			Value = Value1
			; btprefixnext(TreeHandle, Value)
	).

%% btrange/4
%% Jump the tree cursor to the first element whose key has the given prefix,
%% and continue until the UpperBound has been reached.
%% Note this method cannot be called simulaneously on a single tree handle.
%% In order to execute 2 prefix or range queries at the same time, 2 calls 
%% to bt_init must be made (even if to the same tree).
%% Call with:
%% btrange(+TreeHandle, +LowerBound, +UpperBound, -Value).
btrange(TreeHandle, LowerBound, UpperBound, Value) :-
	bt_range_init(TreeHandle, LowerBound, UpperBound),
	btrangenext(TreeHandle, Value).

btrangenext(TreeHandle, Value) :-
	bt_range_next(TreeHandle, Value0),
	(
		unnumbervars(Value0, 0, Value1) ,
		Value = Value1
		; btrangenext(TreeHandle, Value)
	).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Manual Cursor Mode (mcm)
%% This allows the programmer to manually control the cursor.
%%
%% To use, first call btminit(+TreeHandle), then use the preds
%% below to traverse the cursor
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% btminit/1. Initialize MCM on a tree handle. As with prefix
%% and range queries, this ties up this tree handle so it cannot
%% be used for anything else while processing in MCM.
btminit(TreeHandle) :- bt_mcm_init(TreeHandle).

%% btmfirst/1. Move the cursor to the first record in the tree.
btmfirst(TreeHandle) :- bt_mcm_first(TreeHandle).

%% btmlast/1. Move the cursor to the first record in the tree.
btmlast(TreeHandle) :- bt_mcm_last(TreeHandle).

%% btmnext/1. Move the cursor to the next consecutive record in the tree.
btmnext(TreeHandle) :- bt_mcm_next(TreeHandle).

%% btmprev/1. Move the cursor to the previous record in the tree.
btmprev(TreeHandle) :- bt_mcm_prev(TreeHandle).

%% btmjump/2. Move the cursor to the first record matching the key
%% or the nearest match if there are no matches.
btmjump(TreeHandle, Key) :- bt_mcm_jump(TreeHandle, Key).

%% btmjump_rev/2. Move the cursor to the last record matching the key
%% or the nearest match if there are no matches.
btmjump_rev(TreeHandle, Key) :- bt_mcm_jump_rev(TreeHandle, Key).

%% btmkey/2. Returns the current Key which the cursor is pointing to.
%% Does not affect the cursor position.
btmkey(TreeHandle, Key) :- bt_mcm_key(TreeHandle, Key0), unnumbervars(Key0, 0, Key).

%% btmval/2. Returns the current Value which the cursor is pointing to.
%% Does not affect the cursor position.
%% Notice the use of Val0, from the latest version, calls to the c level
%% functions can be made only with variables when values are returned.
btmval(TreeHandle, Val) :- 
	catch(
		bt_mcm_val(TreeHandle, Val0), 
		_, 
		standard:warning('Corrupt Record Found (should run btpurgecorrupt)')
	), 
	unnumbervars(Val0, 0, Val1), Val = Val1.

%% btmout/1. Deletes the entry which the cursor is currently pointing to.
%% Does not affect the cursor position.
btmout(TreeHandle) :- bt_mcm_out(TreeHandle).


%% btgetall/2. Returns each value in the tree on at a time starting
%% from the first indexed value to the last. NOTE: Uses MCM so it will
%% tie up the tree handle for the time you are using it.
btgetall(TreeHandle, Value) :- 
	btminit(TreeHandle), 
	btmfirst(TreeHandle),
	btgetallnext(TreeHandle, Value).

btgetallnext(TreeHandle, Value) :- 
	btmval(TreeHandle, Value0),
	( 
		unnumbervars(Value0, 0, Value1),
		Value = Value1 ; 
			btmnext(TreeHandle),
			btgetallnext(TreeHandle, Value)
	).


%% btgetall_rev/2. Returns each value in the tree on at a time starting
%% from the last indexed value to the first. NOTE: Uses MCM so it will
%% tie up the tree handle for the time you are using it.
btgetall_rev(TreeHandle, Value) :- 
	btminit(TreeHandle), 
	btmlast(TreeHandle),
	btgetallprev(TreeHandle, Value).

btgetallprev(TreeHandle, Value) :- 
	btmval(TreeHandle, Value0),
	( 
		unnumbervars(Value0, 0, Value1),
		Value = Value1 ; 
		btmprev(TreeHandle),
		btgetallprev(TreeHandle, Value)
	).


%% btgetall_key/2. Returns each key in the tree on at a time starting
%% from the first indexed value to the last. NOTE: Uses MCM so it will
%% tie up the tree handle for the time you are using it.
btgetall_key(TreeHandle, Value) :- 
	btminit(TreeHandle), 
	btmfirst(TreeHandle),
	btgetallnext_key(TreeHandle, Value).

btgetallnext_key(TreeHandle, Value) :- 
	btmkey(TreeHandle, Value0),
	( 
		unnumbervars(Value0, 0, Value1),
		Value = Value1  ; 
			bt_mcm_next_key(TreeHandle),
			btgetallnext_key(TreeHandle, Value)
	).

%% btgetall_rev/2. Returns each key in the tree on at a time starting
%% from the last indexed value to the first. NOTE: Uses MCM so it will
%% tie up the tree handle for the time you are using it.
btgetall_key_rev(TreeHandle, Value) :- 
	btminit(TreeHandle), 
	btmlast(TreeHandle),
	btgetallnext_key_rev(TreeHandle, Value).

btgetallnext_key_rev(TreeHandle, Value) :- 
	btmkey(TreeHandle, Value0),
	( 
		unnumbervars(Value0, 0, Value1),
		Value = Value1  ; 
			btmprev(TreeHandle),
			btgetallnext_key_rev(TreeHandle, Value)
	).


%% btname/2. Returns the name of the tree identified by the handle.
%% This name also identifies the directory in which the tree files
%% are held.
btname(Handle, Name) :- bt_tree_name(Handle, Name).

%% btstrans/1. Initiates a transaction on the given database.
btstrans(Handle) :- bt_trans_start(Handle).

%% btctrans/1. Commits a transaction on the given database.
btctrans(Handle) :- bt_trans_commit(Handle).

%% btatrans/1. Aborts a transaction on the given database.
btatrans(Handle) :- bt_trans_abort(Handle).

%% Backup and Restoring DBs (via btexport/2 and btimport/2).
%% btexport/2. Exports the data from the btree into an ordering
%% independant format which can be shared and reloaded. 
%% NOTE: on a 9.2 GB database this process took > 24 hours
%% btexport(TreeHandle, Filename)
btexport(TreeHandle, Filename) :- bt_export(TreeHandle, Filename).

%% btimport/2. Imports the data from the database file into the 
%% given database. 
%% NOTE: The database MUST be open, and the filename provided must
%% refer to a file which was generated by calls to btexport/2 (or the
%% lower level c equivalent bt_export/2).
%% btimport(TreeHandle, Filename)
btimport(TreeHandle, Filename) :- bt_import(TreeHandle, Filename).

%% btpurgecorrupt/1. Traverses all elements in the database,
%% if an error occurs on a record, it is deleted. This can be
%% used to delete "EOF" or other plagued entries in the database
%% without reloading the db.
%% NOTE: This does function similarly to btgetall/2 which can take a __very__ long time.
%% It also does all actions inside a transaction, so if the function
%% does not complete successfully no changes should be made to the DB.
btpurgecorrupt(TreeHandle) :-
	bt_trans_start(TreeHandle),
	bt_mcm_init(TreeHandle),
	bt_mcm_first(TreeHandle),
	btpurgenext(TreeHandle),
	bt_trans_commit(TreeHandle).

btpurgenext(TreeHandle) :-
	catch(
		bt_mcm_val(TreeHandle, _ ), 	%% Try to get the value
		_, 								%% Catch any exception
		(								%% On exception, try to repair the record.
			%% bt_cur_enc_repair/bt_cur_enc_repair_fone
			bt_cur_enc_repair_fone(TreeHandle) 
			-> 
				writeln('Record Repaired.')
			; 
				(
					writeln('Enc repair failed, removing entry.'),
					bt_mcm_out(TreeHandle)		
				)		
		)
	),
	bt_mcm_next(TreeHandle),
	btpurgenext(TreeHandle).

%% btrepair/2. Attempts to repair a corrupted database. This repair function should be used
%% if you are unable to open the database at all, this will not fix broken records (for that
%% try the btpurgecorrupt/1 functionality.) There is almost a garuntee that data will be lost 
%% in this process, but most of it should remain in tact (in one instance a database with ~29 million
%% records was reduced to ~26 million, but the database was successfully recovered).
%% This function cannot be called on a tree handle, it must refer to the database by arguments
%% for instance: btrepair(quad/4,1). Where the predicate quad (arity 4) indexed on the first argument.
%% is the database we will be repairing.
btrepair(Pred/Arity, Indexon) :- bt_repair(Pred/Arity, Indexon).

